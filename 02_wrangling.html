<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Introduction to Data Science</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/metropolis-fonts.css" rel="stylesheet" />
    <link href="libs/tile-view/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view/tile-view.js"></script>
    <script src="libs/fabric/fabric.min.js"></script>
    <link href="libs/xaringanExtra-scribble/scribble.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-scribble/scribble.js"></script>
    <script>document.addEventListener('DOMContentLoaded', function() { window.xeScribble = new Scribble({"pen_color":["#FF0000"],"pen_size":3,"eraser_size":30}) })</script>
    <script src="libs/clipboard/clipboard.min.js"></script>
    <link href="libs/xaringanExtra-clipboard/xaringanExtra-clipboard.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-clipboard/xaringanExtra-clipboard.js"></script>
    <script>window.xaringanExtraClipboard(null, {"button":"Copy Pasta","success":"Copied!","error":"Press Ctrl+C to Copy"})</script>
    <link href="libs/xaringanExtra-extra-styles/xaringanExtra-extra-styles.css" rel="stylesheet" />
    <link href="libs/tachyons/tachyons.min.css" rel="stylesheet" />
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Introduction to Data Science
## Data wrangling with dplyr
### Fall 2021

---

class: header_background
#dplyr




We introduce the **dplyr** package written by Hadley Wickham, Roman Fran&amp;ccedil;ois, Lionel Henry, and Kirill M&amp;uuml;ller. This package is a core member of the **tidyverse** approach to data manipulation; the tidyverse provides a coherent framework for reading, pre-processing/wrangling, visualizing, and modeling data.

There are five main important *verbs* associated with dplyr, namely

+ [filter](https://dplyr.tidyverse.org/reference/filter.html)
+ [select](https://dplyr.tidyverse.org/reference/select.html)
+ [arrange](https://dplyr.tidyverse.org/reference/arrange.html)
+ [mutate](https://dplyr.tidyverse.org/reference/mutate.html) and [rename](https://dplyr.tidyverse.org/reference/rename.html)
+ [group_by](https://dplyr.tidyverse.org/reference/group_by.html) and [summarize](https://dplyr.tidyverse.org/reference/summarise.html)

---
class: clear, animated, bounceInDown
We shall follow an an abbreviated presentation from Chapter 5 of [R for data science](https://r4ds.had.co.nz/). 

We first load the *flights13* dataset from the **nycflights13** package. This dataset describe the on-time data for all flights departing from NYC airports (i.e. JFK, LGA or EWA) in 2013.


```r
library(tidyverse)
library(nycflights13)
data(flights)
flights
```

```
## # A tibble: 336,776 x 19
##    year month   day dep_time sched_dep_time dep_delay arr_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
## 1  2013     1     1      517            515         2      830
## 2  2013     1     1      533            529         4      850
## 3  2013     1     1      542            540         2      923
## 4  2013     1     1      544            545        -1     1004
## 5  2013     1     1      554            600        -6      812
## 6  2013     1     1      554            558        -4      740
## # … with 336,770 more rows, and 12 more variables:
## #   sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;,
## #   flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;,
## #   air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```
---
class: header_background
#filter()
Let us find flights departing NYC on August 21. Note that **dplyr** verbs takes a data frame and returns a new data frame.

```r
filter(flights, month == 8, day == 21)
```

```
## # A tibble: 990 x 19
##    year month   day dep_time sched_dep_time dep_delay arr_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
## 1  2013     8    21       10           2359        11      350
## 2  2013     8    21       36           2359        37      413
## 3  2013     8    21       48           1620       508      251
## 4  2013     8    21      453            500        -7      634
## 5  2013     8    21      528            530        -2      757
## 6  2013     8    21      536            545        -9      808
## # … with 984 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;
```

```r
## Equivalently: filter(flights, month == 8 &amp; day == 21)
```
---
class: clear
Next, let us try to filter flights from August 21, 2013 that departs from either JFK or LGA.

```r
august21 &lt;- filter(flights, month == 8 &amp; day == 21)
filter(august21, origin == 'JFK' | origin == 'LGA') 
```

```
## # A tibble: 637 x 19
##    year month   day dep_time sched_dep_time dep_delay arr_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
## 1  2013     8    21       10           2359        11      350
## 2  2013     8    21       36           2359        37      413
## 3  2013     8    21       48           1620       508      251
## 4  2013     8    21      536            545        -9      808
## 5  2013     8    21      540            540         0      837
## 6  2013     8    21      544            545        -1      911
## # … with 631 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;
```

```r
## Equivalently: filter(august21, origin %in% c("JFK","LGA"))
```
---
class: clear
Let us now check, among all the flights on August 21 from either JFK or LGA, which of them has a departure or arrival delay of 10 minutes or more.

```r
august21_jfk_lga &lt;- filter(august21, origin %in% c("JFK","LGA"))
filter(august21_jfk_lga, arr_delay &gt; 10 | dep_delay &gt; 10)
```

```
## # A tibble: 106 x 19
##    year month   day dep_time sched_dep_time dep_delay arr_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
## 1  2013     8    21       10           2359        11      350
## 2  2013     8    21       36           2359        37      413
## 3  2013     8    21       48           1620       508      251
## 4  2013     8    21      555            600        -5      839
## 5  2013     8    21      558            600        -2      830
## 6  2013     8    21      625            600        25      903
## # … with 100 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;
```
---
class: clear
We can do all of the above filtering using a single chain sequence as follows

```r
flights %&gt;% filter(month == 8 &amp; day == 21) %&gt;% 
            filter(origin %in% c("JFK","LGA")) %&gt;%
            filter(arr_delay &gt; 10 | dep_delay &gt; 10)
```

```
## # A tibble: 106 x 19
##    year month   day dep_time sched_dep_time dep_delay arr_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
## 1  2013     8    21       10           2359        11      350
## 2  2013     8    21       36           2359        37      413
## 3  2013     8    21       48           1620       508      251
## 4  2013     8    21      555            600        -5      839
## 5  2013     8    21      558            600        -2      830
## 6  2013     8    21      625            600        25      903
## # … with 100 more rows, and 12 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;
```

The previous example introduce the use of the `\(\%&gt;\%\)` pipe operator. 
The pipe operator allows us an elegant way to chain together a sequence of operations without the need to introduce auxiliary variables.
The pipe operator maps `\(x \%&gt;\% f(y)\)` to `\(f(x,y)\)`. 
---
class: header_background
#Missing values
Missing values are represented in **R** as `\(\mathrm{NA}\)`; missing values are "contagious" hence any almost all operations involving one or more `\(\mathrm{NA}\)` will also return a `\(\mathrm{NA}\)`. For example

```r
NA &gt; 5
```

```
## [1] NA
```

```r
10 == NA
```

```
## [1] NA
```

```r
NA + 10
```

```
## [1] NA
```

```r
2*NA
```

```
## [1] NA
```
---
class: clear
Further examples include

```r
NA == NA
```

```
## [1] NA
```

```r
0*NA
```

```
## [1] NA
```

```r
NA^0
```

```
## [1] 1
```

```r
NA | TRUE
```

```
## [1] TRUE
```

```r
FALSE &amp; NA
```

```
## [1] FALSE
```
---
class: clear
**filter** only includes rows where the condition is `\(\mathrm{TRUE}\)`, i.e., it excludes rows with both `\(\mathrm{FALSE}\)` and `\(\mathrm{NA}\)` values. To preserve missing values, we have to ask for them explicitly, e.g.,

```r
df &lt;- tibble(x = c(1, NA, 3))
filter(df, x &gt; 1)
```

```
## # A tibble: 1 x 1
##       x
##   &lt;dbl&gt;
## 1     3
```

```r
filter(df, is.na(x) | x &gt; 1)
```

```
## # A tibble: 2 x 1
##       x
##   &lt;dbl&gt;
## 1    NA
## 2     3
```
---
class: header_background
#arrange()
The *arrange* verb is similar to the *filter* verb, but instead of selecting rows, it reorder them according to some set of column names (or more complicated expressions). As an example, let us order the flights first by the three letter code for the airport destination, then by the date of flight.

```r
flights_dest &lt;- select(flights, dest, everything()) 
arrange(flights_dest, dest, month, day)
```

```
## # A tibble: 336,776 x 19
##   dest   year month   day dep_time sched_dep_time dep_delay arr_time
##   &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
## 1 ABQ    2013     4    22     1712           1630        42     1946
## 2 ABQ    2013     4    23     2022           2025        -3     2319
## 3 ABQ    2013     4    24     2037           2025        12       14
## 4 ABQ    2013     4    25     2023           2025        -2     2339
## 5 ABQ    2013     4    26     2020           2025        -5     2318
## 6 ABQ    2013     4    27     2020           2025        -5     2245
## # … with 336,770 more rows, and 11 more variables:
## #   sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;,
## #   flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;
```
---
class: clear
We can use **desc** to order a column in descending order, e.g.,

```r
arrange(flights_dest, desc(dest), month, day)
```

```
## # A tibble: 336,776 x 19
##   dest   year month   day dep_time sched_dep_time dep_delay arr_time
##   &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
## 1 XNA    2013     1     1      656            705        -9     1007
## 2 XNA    2013     1     1     1525           1530        -5     1934
## 3 XNA    2013     1     1     1740           1745        -5     2158
## 4 XNA    2013     1     2      656            705        -9     1014
## 5 XNA    2013     1     2      905            822        43     1313
## 6 XNA    2013     1     2     1531           1530         1     1846
## # … with 336,770 more rows, and 11 more variables:
## #   sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;,
## #   flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;
```
---
class: header_background
#select()
This verb is used to select a subset of columns (of variables). As an example, let us keep only the departure and arrival time of the flights.

```r
flights_sml &lt;- select(flights, year, month, day, 
                      dep_time, sched_dep_time, 
                      arr_time, sched_arr_time)
flights_sml
```

```
## # A tibble: 336,776 x 7
##    year month   day dep_time sched_dep_time arr_time sched_arr_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;    &lt;int&gt;          &lt;int&gt;
## 1  2013     1     1      517            515      830            819
## 2  2013     1     1      533            529      850            830
## 3  2013     1     1      542            540      923            850
## 4  2013     1     1      544            545     1004           1022
## 5  2013     1     1      554            600      812            837
## 6  2013     1     1      554            558      740            728
## # … with 336,770 more rows
```
---
class: clear
There are a few equivalent way to do the above selection, e.g.,

```r
names(flights)
```

```
##  [1] "year"           "month"          "day"            "dep_time"      
##  [5] "sched_dep_time" "dep_delay"      "arr_time"       "sched_arr_time"
##  [9] "arr_delay"      "carrier"        "flight"         "tailnum"       
## [13] "origin"         "dest"           "air_time"       "distance"      
## [17] "hour"           "minute"         "time_hour"
```

```r
## flights_sml &lt;- select(flights, year:day, dep_time, 
##                       sched_dep_time, arr_time, sched_arr_time)
## flights_sml &lt;- select(flights, year:day, contains("dep_time"),
##                       contains("arr_time"))
## flights_sml &lt;- select(flights, year:day, contains("time"),
##                      -c(air_time,time_hour))
```
---
class: clear
We can also rename variables using *select*; however this will lead to the dropping of variables that are not explicitly mentioned. A better alternative is to use *rename*, e.g.,

```r
rename(flights_sml,
       departure_time = dep_time, arrival_time = arr_time)
```

```
## # A tibble: 336,776 x 7
##    year month   day departure_time sched_dep_time arrival_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;          &lt;int&gt;          &lt;int&gt;        &lt;int&gt;
## 1  2013     1     1            517            515          830
## 2  2013     1     1            533            529          850
## 3  2013     1     1            542            540          923
## 4  2013     1     1            544            545         1004
## 5  2013     1     1            554            600          812
## 6  2013     1     1            554            558          740
## # … with 336,770 more rows, and 1 more variable: sched_arr_time &lt;int&gt;
```
---
class: clear
A useful helper function for use with select is the **everything()** function, which matches all variables. For example, to move a specific variable to the first column of data frame, we can do

```r
select(flights_sml, dep_time, everything())
```

```
## # A tibble: 336,776 x 7
##   dep_time  year month   day sched_dep_time arr_time sched_arr_time
##      &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;          &lt;int&gt;    &lt;int&gt;          &lt;int&gt;
## 1      517  2013     1     1            515      830            819
## 2      533  2013     1     1            529      850            830
## 3      542  2013     1     1            540      923            850
## 4      544  2013     1     1            545     1004           1022
## 5      554  2013     1     1            600      812            837
## 6      554  2013     1     1            558      740            728
## # … with 336,770 more rows
```
---
class: header_background
# mutate()
The *mutate* verb is used to add new columns (that are possibly functions of existing columns) to a data frame; the new columns are always added as the last columns. For example

```r
flights_sml &lt;- select(flights, year:day,ends_with("delay"),
                      distance, air_time)
mutate(flights_sml, gain = arr_delay - dep_delay,
                    hours = air_time/60,
                    speed = distance/hours,
                    gain_per_hour = gain/hours) %&gt;% select(-hours)
```

```
## # A tibble: 336,776 x 10
##    year month   day dep_delay arr_delay distance air_time  gain speed
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1  2013     1     1         2        11     1400      227     9  370.
## 2  2013     1     1         4        20     1416      227    16  374.
## 3  2013     1     1         2        33     1089      160    31  408.
## 4  2013     1     1        -1       -18     1576      183   -17  517.
## 5  2013     1     1        -6       -25      762      116   -19  394.
## 6  2013     1     1        -4        12      719      150    16  288.
## # … with 336,770 more rows, and 1 more variable: gain_per_hour &lt;dbl&gt;
```
---
class: clear
A variant of *mutate* is *transmute*, which drops all variables except the newly created variables, e.g.,

```r
transmute(flights, gain = arr_delay - dep_delay, 
                   hours = air_time/60, 
                   gain_per_hour = gain/hours)
```

```
## # A tibble: 336,776 x 3
##    gain hours gain_per_hour
##   &lt;dbl&gt; &lt;dbl&gt;         &lt;dbl&gt;
## 1     9  3.78          2.38
## 2    16  3.78          4.23
## 3    31  2.67         11.6 
## 4   -17  3.05         -5.57
## 5   -19  1.93         -9.83
## 6    16  2.5           6.4 
## # … with 336,770 more rows
```
---
class: header_background
#summarize()
The *summarize* verb collapses a data frame to a single row. For example

```r
summarize(flights, delay = mean(dep_delay)) ## oops! missing values
```

```
## # A tibble: 1 x 1
##   delay
##   &lt;dbl&gt;
## 1    NA
```

```r
summarize(flights, delay = mean(dep_delay, na.rm = TRUE))
```

```
## # A tibble: 1 x 1
##   delay
##   &lt;dbl&gt;
## 1  12.6
```
---
class: clear
This is not terribly exciting. The power of *summarize* comes from its combination with **groub_by()**, allowing us to do *grouped summaries*, i.e., summary statistics on individual groups. For example

```r
flights %&gt;% group_by(year, month, day)
```

```
## # A tibble: 336,776 x 19
## # Groups:   year, month, day [365]
##    year month   day dep_time sched_dep_time dep_delay arr_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
## 1  2013     1     1      517            515         2      830
## 2  2013     1     1      533            529         4      850
## 3  2013     1     1      542            540         2      923
## 4  2013     1     1      544            545        -1     1004
## 5  2013     1     1      554            600        -6      812
## 6  2013     1     1      554            558        -4      740
## # … with 336,770 more rows, and 12 more variables:
## #   sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;,
## #   flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;,
## #   air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```
---
class: clear

```r
flights %&gt;% group_by(year, month, day) %&gt;%
summarize(delay = mean(dep_delay, na.rm = TRUE))
```

```
## # A tibble: 365 x 4
## # Groups:   year, month [12]
##    year month   day delay
##   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;
## 1  2013     1     1 11.5 
## 2  2013     1     2 13.9 
## 3  2013     1     3 11.0 
## 4  2013     1     4  8.95
## 5  2013     1     5  5.73
## 6  2013     1     6  7.15
## # … with 359 more rows
```
---
class: clear
A more involved example is to compute the average distance and delay for flights to all destinations (except Honolulu).

```r
delays &lt;- flights %&gt;% group_by(dest) %&gt;% 
  summarize(count = n(), 
            dist = mean(distance,na.rm = TRUE),
            avg_delay = mean(arr_delay + dep_delay,na.rm = TRUE)
            ) %&gt;%
  filter(count &gt; 20, dest != "HNL")
delays
```

```
## # A tibble: 96 x 4
##   dest  count  dist avg_delay
##   &lt;chr&gt; &lt;int&gt; &lt;dbl&gt;     &lt;dbl&gt;
## 1 ABQ     254 1826       18.1
## 2 ACK     265  199       11.3
## 3 ALB     439  143       37.8
## 4 ATL   17215  757.      23.7
## 5 AUS    2439 1514.      19.0
## 6 AVL     275  584.      16.2
## # … with 90 more rows
```
---
class: clear
We can then plot how the average delay varies with the distance.

```r
library(ggplot2)
ggplot(delays, aes(x = dist, y  = avg_delay)) + 
  geom_point(aes(size = count)) +
  geom_smooth(se = FALSE) + ylab("average delay") + theme_bw()
```

&lt;img src="02_wrangling_files/figure-html/unnamed-chunk-21-1.png" width="80%" style="display: block; margin: auto;" /&gt;
---
class: clear
There are a large number of useful summary functions. See Section 5.6.4 of [R4DS](https://r4ds.had.co.nz/transform.html#summarise-funs). We provide a few more examples.

```r
## average arrival delay
not_canceled &lt;- filter(flights, !is.na(dep_delay) &amp; !is.na(arr_delay))
not_canceled %&gt;% group_by(year, month, day) %&gt;% 
  summarize(avg_delay = mean(arr_delay), 
            avg_positive_delay = mean(arr_delay[arr_delay &gt; 0]))
```

```
## # A tibble: 365 x 5
## # Groups:   year, month [12]
##    year month   day avg_delay avg_positive_delay
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;              &lt;dbl&gt;
## 1  2013     1     1     12.7                32.5
## 2  2013     1     2     12.7                32.0
## 3  2013     1     3      5.73               27.7
## 4  2013     1     4     -1.93               28.3
## 5  2013     1     5     -1.53               22.6
## 6  2013     1     6      4.24               24.4
## # … with 359 more rows
```
---
class: clear

```r
not_canceled %&gt;% group_by(dest) %&gt;% 
  summarize(dist_sd = sd(distance)) %&gt;% arrange(desc(dist_sd))
```

```
## # A tibble: 104 x 2
##   dest  dist_sd
##   &lt;chr&gt;   &lt;dbl&gt;
## 1 EGE     10.5 
## 2 SAN     10.4 
## 3 SFO     10.2 
## 4 HNL     10.0 
## 5 SEA      9.98
## 6 LAS      9.91
## # … with 98 more rows
```
---
class: clear
We note that *summarize* drops all variables except possibly those used to group the data and those variables introduced by the summary statistics. Contrasts the following two approaches

```r
not_canceled %&gt;% group_by(year,month,day) %&gt;%
  summarize(first_dep = first(dep_time), last_dep = last(dep_time))
```

```
## # A tibble: 365 x 5
## # Groups:   year, month [12]
##    year month   day first_dep last_dep
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;int&gt;    &lt;int&gt;
## 1  2013     1     1       517     2356
## 2  2013     1     2        42     2354
## 3  2013     1     3        32     2349
## 4  2013     1     4        25     2358
## 5  2013     1     5        14     2357
## 6  2013     1     6        16     2355
## # … with 359 more rows
```
---
class: clear

```r
not_canceled %&gt;% group_by(year, month, day) %&gt;%
  mutate(r = min_rank(desc(dep_time))) %&gt;% filter(r %in% range(r))
```

```
## # A tibble: 770 x 20
## # Groups:   year, month, day [365]
##    year month   day dep_time sched_dep_time dep_delay arr_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
## 1  2013     1     1      517            515         2      830
## 2  2013     1     1     2356           2359        -3      425
## 3  2013     1     2       42           2359        43      518
## 4  2013     1     2     2354           2359        -5      413
## 5  2013     1     3       32           2359        33      504
## 6  2013     1     3     2349           2359       -10      434
## # … with 764 more rows, and 13 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;,
## #   origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, r &lt;int&gt;
```
---
class: header_background
# More examples

```r
not_canceled %&gt;% group_by(year, month, day) %&gt;%
  summarize(n_early = sum(dep_time &lt; 500))
```

```
## # A tibble: 365 x 4
## # Groups:   year, month [12]
##    year month   day n_early
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;int&gt;
## 1  2013     1     1       0
## 2  2013     1     2       3
## 3  2013     1     3       4
## 4  2013     1     4       3
## 5  2013     1     5       3
## 6  2013     1     6       2
## # … with 359 more rows
```
---
class: clear

```r
not_canceled %&gt;% group_by(dest) %&gt;%
  summarize(long_delay_pct = mean(arr_delay &gt; 60)) %&gt;%
  arrange(desc(long_delay_pct))
```

```
## # A tibble: 104 x 2
##   dest  long_delay_pct
##   &lt;chr&gt;          &lt;dbl&gt;
## 1 CAE            0.255
## 2 TUL            0.245
## 3 OKC            0.216
## 4 TYS            0.206
## 5 BHM            0.171
## 6 DSM            0.170
## # … with 98 more rows
```
---
class: clear
Finally, when you group by multiple variables, each call to `\(\mathrm{summary}\)` peels off one level of the grouping, e.g.,

```r
daily &lt;- group_by(flights, dest, month, day)
daily
```

```
## # A tibble: 336,776 x 19
## # Groups:   dest, month, day [31,229]
##    year month   day dep_time sched_dep_time dep_delay arr_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
## 1  2013     1     1      517            515         2      830
## 2  2013     1     1      533            529         4      850
## 3  2013     1     1      542            540         2      923
## 4  2013     1     1      544            545        -1     1004
## 5  2013     1     1      554            600        -6      812
## 6  2013     1     1      554            558        -4      740
## # … with 336,770 more rows, and 12 more variables:
## #   sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;,
## #   flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;,
## #   air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```
---
class:clear

```r
daily %&gt;% summarize(flights = n()) %&gt;% 
          summarize(flights = sum(flights)) %&gt;%
          summarize(flights = sum(flights)) 
```

```
## # A tibble: 105 x 2
##   dest  flights
##   &lt;chr&gt;   &lt;int&gt;
## 1 ABQ       254
## 2 ACK       265
## 3 ALB       439
## 4 ANC         8
## 5 ATL     17215
## 6 AUS      2439
## # … with 99 more rows
```
---
class: clear
Be careful when peeling off nested groupings using a sequence of `\(\mathrm{summarize}\)`. 

Consider the following examples.


```r
group_by(not_canceled, dest, month) %&gt;% 
  summarize(air_time = mean(air_time)) %&gt;% 
  summarize(air_time = mean(air_time))
```

```
## # A tibble: 104 x 2
##   dest  air_time
##   &lt;chr&gt;    &lt;dbl&gt;
## 1 ABQ      250. 
## 2 ACK       41.9
## 3 ALB       31.8
## 4 ANC      413. 
## 5 ATL      113. 
## 6 AUS      214. 
## # … with 98 more rows
```
---
class: clear

```r
group_by(not_canceled, dest) %&gt;% 
  summarize(air_time = mean(air_time))
```

```
## # A tibble: 104 x 2
##   dest  air_time
##   &lt;chr&gt;    &lt;dbl&gt;
## 1 ABQ      249. 
## 2 ACK       42.1
## 3 ALB       31.8
## 4 ANC      413. 
## 5 ATL      113. 
## 6 AUS      213. 
## # … with 98 more rows
```
---
class: clear

```r
group_by(not_canceled, dest, month) %&gt;% 
  summarize(air_time = median(air_time)) %&gt;% 
  summarize(air_time = median(air_time))
```

```
## # A tibble: 104 x 2
##   dest  air_time
##   &lt;chr&gt;    &lt;dbl&gt;
## 1 ABQ      244  
## 2 ACK       40.5
## 3 ALB       31  
## 4 ANC      415. 
## 5 ATL      110  
## 6 AUS      214. 
## # … with 98 more rows
```
---
class: clear

```r
group_by(not_canceled, dest) %&gt;% 
  summarize(air_time = median(air_time))
```

```
## # A tibble: 104 x 2
##   dest  air_time
##   &lt;chr&gt;    &lt;dbl&gt;
## 1 ABQ       246 
## 2 ACK        41 
## 3 ALB        31 
## 4 ANC       414.
## 5 ATL       112 
## 6 AUS       211 
## # … with 98 more rows
```
---
class: header_background
#ungroup()
To remove grouping structure on grouped data, use `\(\mathrm{ungroup()}\)`, e.g.,

```r
daily &lt;- group_by(flights, year, month, day)
summarize(daily, flights = n())
```

```
## # A tibble: 365 x 4
## # Groups:   year, month [12]
##    year month   day flights
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;int&gt;
## 1  2013     1     1     842
## 2  2013     1     2     943
## 3  2013     1     3     914
## 4  2013     1     4     915
## 5  2013     1     5     720
## 6  2013     1     6     832
## # … with 359 more rows
```

```r
daily %&gt;% ungroup() %&gt;% summarize(flights = n())
```

```
## # A tibble: 1 x 1
##   flights
##     &lt;int&gt;
## 1  336776
```
---
class: header_background
#grouped mutate + filter
We can also do a number of very useful operations by combining `\(\mathrm{group\_by}\)` with either `\(\mathrm{filter}\)` or `\(\mathrm{filter}\)`. For example

```r
## Find the worst flights with longest delay each day
flights_sml &lt;- select(flights, year:day, ends_with("delay"),
                      distance, air_time)
flights_sml %&gt;% group_by(year, month, day) %&gt;%
  filter(rank(desc(arr_delay)) &lt;= 10)
```

```
## # A tibble: 3,609 x 7
## # Groups:   year, month, day [365]
##    year month   day dep_delay arr_delay distance air_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;
## 1  2013     1     1       853       851      184       41
## 2  2013     1     1       290       338     1134      213
## 3  2013     1     1       260       263      266       46
## 4  2013     1     1       155       166      277       68
## 5  2013     1     1       157       174      213       60
## 6  2013     1     1       216       222      708      121
## # … with 3,603 more rows
```
---
class: clear

```r
## Find all popular destinations and compute
## proportion of total delay for each flights
flights %&gt;% group_by(dest) %&gt;%
  filter(n() &gt; 365, arr_delay &gt; 0) %&gt;%
  mutate(prop_delay = arr_delay/sum(arr_delay)) %&gt;%
  select(year:day, dest, arr_delay, prop_delay)
```

```
## # A tibble: 131,106 x 6
## # Groups:   dest [77]
##    year month   day dest  arr_delay prop_delay
##   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;      &lt;dbl&gt;
## 1  2013     1     1 IAH          11  0.000111 
## 2  2013     1     1 IAH          20  0.000201 
## 3  2013     1     1 MIA          33  0.000235 
## 4  2013     1     1 ORD          12  0.0000424
## 5  2013     1     1 FLL          19  0.0000938
## 6  2013     1     1 ORD           8  0.0000283
## # … with 131,100 more rows
```
---
class: clear
Functions that work most naturally in grouped mutates and grouped filters are [window functions](https://rpubs.com/hadley/window) (see the **R** command `\(\mathrm{vignette("window-functions")}\)`. 

The following example is from [window functions](https://rpubs.com/hadley/window). The example uses a dataset from the **Lahman** database that contains pitching, hitting, and fielding statistics for MLB from `\(1871\)` through `\(2018\)`. We will consider a sample of batting data for players that have won an award.

```r
library(Lahman)
batting &lt;- Lahman::Batting %&gt;% as_tibble() %&gt;% 
           select(playerID, yearID, teamID, G, AB, R, H) %&gt;%
           arrange(playerID, yearID, teamID) %&gt;%
           semi_join(Lahman::AwardsPlayers, by = "playerID")
players &lt;- batting %&gt;% group_by(playerID)
```
---
class: clear
Using this dataset, let us try a few `\(\mathrm{group\_mutate}\)` and `\(\mathrm{group\_filter}\)` operations. 

```r
## For each player, find the two years with most hits
filter(players, min_rank(desc(H)) &lt;= 2 &amp; H &gt; 0)
```

```
## # A tibble: 2,777 x 7
## # Groups:   playerID [1,315]
##   playerID  yearID teamID     G    AB     R     H
##   &lt;chr&gt;      &lt;int&gt; &lt;fct&gt;  &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;
## 1 aaronha01   1959 ML1      154   629   116   223
## 2 aaronha01   1963 ML1      161   631   121   201
## 3 abbotji01   1999 MIL       20    21     0     2
## 4 abernte02   1955 WS1       40    26     1     4
## 5 abernte02   1957 WS1       26    24     3     4
## 6 abreubo01   1999 PHI      152   546   118   183
## # … with 2,771 more rows
```
---
class: clear

```r
## For each player, rank each year by the number of games played
mutate(players, G_rank = min_rank(G))
```

```
## # A tibble: 19,978 x 8
## # Groups:   playerID [1,359]
##   playerID  yearID teamID     G    AB     R     H G_rank
##   &lt;chr&gt;      &lt;int&gt; &lt;fct&gt;  &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;int&gt;
## 1 aaronha01   1954 ML1      122   468    58   131      4
## 2 aaronha01   1955 ML1      153   602   105   189     13
## 3 aaronha01   1956 ML1      153   609   106   200     13
## 4 aaronha01   1957 ML1      151   615   118   198     12
## 5 aaronha01   1958 ML1      153   601   109   196     13
## 6 aaronha01   1959 ML1      154   629   116   223     17
## # … with 19,972 more rows
```
---
class: clear

```r
## For each player, find every year that was 
## better than the previous year
filter(players, AB &gt; 0, lag(AB) &gt; 0, H/AB &gt; lag(H)/lag(AB))
```

```
## # A tibble: 7,945 x 7
## # Groups:   playerID [1,291]
##   playerID  yearID teamID     G    AB     R     H
##   &lt;chr&gt;      &lt;int&gt; &lt;fct&gt;  &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;
## 1 aaronha01   1955 ML1      153   602   105   189
## 2 aaronha01   1956 ML1      153   609   106   200
## 3 aaronha01   1958 ML1      153   601   109   196
## 4 aaronha01   1959 ML1      154   629   116   223
## 5 aaronha01   1961 ML1      155   603   115   197
## 6 aaronha01   1964 ML1      145   570   103   187
## # … with 7,939 more rows
```
---
class: clear

```r
# For each, player compute a z score based on number of games played
mutate(players, G_z = (G - mean(G)) / sd(G))
```

```
## # A tibble: 19,978 x 8
## # Groups:   playerID [1,359]
##   playerID  yearID teamID     G    AB     R     H    G_z
##   &lt;chr&gt;      &lt;int&gt; &lt;fct&gt;  &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;dbl&gt;
## 1 aaronha01   1954 ML1      122   468    58   131 -1.16 
## 2 aaronha01   1955 ML1      153   602   105   189  0.519
## 3 aaronha01   1956 ML1      153   609   106   200  0.519
## 4 aaronha01   1957 ML1      151   615   118   198  0.411
## 5 aaronha01   1958 ML1      153   601   109   196  0.519
## 6 aaronha01   1959 ML1      154   629   116   223  0.573
## # … with 19,972 more rows
```
---
class: clear
The `\(\mathrm{ntile(x,m)}\)` function divides the (numeric) vector `\(x\)` into `\(m\)` evenly sized buckets. The next operation divides the team players into `\(4\)` coarse groups and calculate the batting average for each group.

```r
batting %&gt;% group_by(teamID,playerID) %&gt;%
  summarise(total_hits = sum(H), total_ab = sum(AB), 
            batting_avg = total_hits/total_ab) %&gt;%
  filter(!is.na(batting_avg)) %&gt;%
  mutate(quartile = ntile(batting_avg,4)) %&gt;%
  group_by(teamID,quartile) %&gt;% 
  summarise(batting_avg = sum(total_hits)/sum(total_ab))
```

```
## # A tibble: 235 x 3
## # Groups:   teamID [79]
##   teamID quartile batting_avg
##   &lt;fct&gt;     &lt;int&gt;       &lt;dbl&gt;
## 1 ANA           1       0.184
## 2 ANA           2       0.261
## 3 ANA           3       0.282
## 4 ANA           4       0.301
## 5 ARI           1       0.157
## 6 ARI           2       0.258
## # … with 229 more rows
```
---
class: header_background
#Scoped variants of dplyr verbs
The dplyr verbs we see before also have **scoped** variants with the suffixes `\(\_\mathrm{if}\)`, `\(\_\mathrm{at}\)` and `\(\_\mathrm{all}\)`. 

+ `\(\_\mathrm{if}\)` pick variables based on a *predicate* function, e.g., `\(\mathrm{is.numeric()}\)`.
+ `\(\_\mathrm{at}\)` pick variables using the same syntax as `\(\mathrm{select}\)`
+ `\(\_\mathrm{all}\)` operates on all variables.

These variants are best illustrated using examples. For more details see the [cheat sheet](https://github.com/dcl-docs/cheat-sheets/blob/master/scoped_verbs.md).
.pull-left[

```r
df &lt;- tibble(
  x = runif(100), 
  y = runif(100), z = runif(100))
df
```

```
## # A tibble: 100 x 3
##       x     y     z
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 0.679 0.525 0.853
## 2 0.434 0.380 0.958
## 3 0.407 0.445 0.352
## 4 0.119 0.956 0.372
## 5 0.339 0.349 0.165
## 6 0.159 0.429 0.951
## # … with 94 more rows
```
]
.pull-right[

```r
df %&gt;% summarise_all(mean)
```

```
## # A tibble: 1 x 3
##       x     y     z
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 0.466 0.534 0.492
```
]
---
class:clear
If we want to *name* the returned value, do

```r
df %&gt;% summarise_all(list(mean = mean))
```

```
## # A tibble: 1 x 3
##   x_mean y_mean z_mean
##    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
## 1  0.466  0.534  0.492
```
To get multiple summaries statistics for each column, pass the functions as a list.

```r
df %&gt;% summarise_all(list(mean = mean, sd = sd))
```

```
## # A tibble: 1 x 6
##   x_mean y_mean z_mean  x_sd  y_sd  z_sd
##    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1  0.466  0.534  0.492 0.278 0.269 0.280
```
---
class: clear
We can also define a function and pass it as an argument to `\(\mathrm{summarise\_all}\)`. 

```r
df %&gt;% summarise_all(max/min)
```

```
## Error in max/min: non-numeric argument to binary operator
```

```r
temp.fn &lt;- function(x){
  max(x)/min(x)
}
df %&gt;% summarise_all(temp.fn)
```

```
## # A tibble: 1 x 3
##       x     y     z
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1  367.  78.1  177.
```
---
class: clear
A slightly more complicated syntax is required for passing **anonymous** functions.

```r
df %&gt;% summarise_all(~max(.)/min(.)) 
```

```
## # A tibble: 1 x 3
##       x     y     z
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1  367.  78.1  177.
```

```r
df %&gt;% summarise_all(list(ratio = ~max(.)/min(.), 
                          large_values = ~sum(. &gt; mean(.) + sd(.))))
```

```
## # A tibble: 1 x 6
##   x_ratio y_ratio z_ratio x_large_values y_large_values z_large_values
##     &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;          &lt;int&gt;          &lt;int&gt;          &lt;int&gt;
## 1    367.    78.1    177.             20             21             22
```

The previous examples uses the `\(.\)` operator, which serves as a placeholder for the variable/data of interest. See also the documentation for the [magrittr library](https://github.com/tidyverse/magrittr).

---
class: clear
Examples of `\(\mathrm{summarize\_at}\)`; `\(\mathrm{summarize\_at}\)` can use the helper functions of `\(\mathrm{select}\)`. 

```r
df
```

```
## # A tibble: 100 x 3
##       x     y     z
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 0.679 0.525 0.853
## 2 0.434 0.380 0.958
## 3 0.407 0.445 0.352
## 4 0.119 0.956 0.372
## 5 0.339 0.349 0.165
## 6 0.159 0.429 0.951
## # … with 94 more rows
```

```r
df %&gt;% summarise_at(vars(x,y), list(min = min, max = max))
```

```
## # A tibble: 1 x 4
##     x_min  y_min x_max y_max
##     &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 0.00271 0.0125 0.995 0.978
```
---
class: clear


```r
df %&gt;% summarise_at(vars(-z), list(min = min, max = max))
```

```
## # A tibble: 1 x 4
##     x_min  y_min x_max y_max
##     &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 0.00271 0.0125 0.995 0.978
```

```r
df %&gt;% summarise_at(vars(contains("x")), median)
```

```
## # A tibble: 1 x 1
##       x
##   &lt;dbl&gt;
## 1 0.430
```
---
class: clear
Some examples of `\(\mathrm{summarize\_if}\)`.

```r
starwars
```

```
## # A tibble: 87 x 14
##   name  height  mass hair_color skin_color eye_color birth_year sex  
##   &lt;chr&gt;  &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt;
## 1 Luke…    172    77 blond      fair       blue            19   male 
## 2 C-3PO    167    75 &lt;NA&gt;       gold       yellow         112   none 
## 3 R2-D2     96    32 &lt;NA&gt;       white, bl… red             33   none 
## 4 Dart…    202   136 none       white      yellow          41.9 male 
## 5 Leia…    150    49 brown      light      brown           19   fema…
## 6 Owen…    178   120 brown, gr… light      blue            52   male 
## # … with 81 more rows, and 6 more variables: gender &lt;chr&gt;,
## #   homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;, vehicles &lt;list&gt;,
## #   starships &lt;list&gt;
```

```r
starwars %&gt;% 
  summarize_if(is.numeric, list(mean = mean, sd = sd), na.rm = TRUE)
```

```
## # A tibble: 1 x 6
##   height_mean mass_mean birth_year_mean height_sd mass_sd
##         &lt;dbl&gt;     &lt;dbl&gt;           &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;
## 1        174.      97.3            87.6      34.8    169.
## # … with 1 more variable: birth_year_sd &lt;dbl&gt;
```
---
class: clear
Finally, we present examples of `\(\mathrm{filter\_if}\)`, `\(\mathrm{filter\_at}\)` and `\(\mathrm{filter\_all}\)`. These verbs are often used in conjunction with `\(\mathrm{any\_vars}\)` or `\(\mathrm{all\_vars}\)`.

```r
## Find all observations with at least one missing value.
flights %&gt;% filter_all(any_vars(is.na(.))) 
```

```
## # A tibble: 9,430 x 19
##    year month   day dep_time sched_dep_time dep_delay arr_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
## 1  2013     1     1     1525           1530        -5     1934
## 2  2013     1     1     1528           1459        29     2002
## 3  2013     1     1     1740           1745        -5     2158
## 4  2013     1     1     1807           1738        29     2251
## 5  2013     1     1     1939           1840        59       29
## 6  2013     1     1     1952           1930        22     2358
## # … with 9,424 more rows, and 12 more variables:
## #   sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;,
## #   flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;,
## #   air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```
---
class: clear

```r
## Find all flights with little delay
flights %&gt;% filter_at(vars(contains("delay")), all_vars(. &lt; 10))
```

```
## # A tibble: 213,870 x 19
##    year month   day dep_time sched_dep_time dep_delay arr_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
## 1  2013     1     1      544            545        -1     1004
## 2  2013     1     1      554            600        -6      812
## 3  2013     1     1      557            600        -3      709
## 4  2013     1     1      557            600        -3      838
## 5  2013     1     1      558            600        -2      753
## 6  2013     1     1      558            600        -2      849
## # … with 213,864 more rows, and 12 more variables:
## #   sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;,
## #   flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;,
## #   air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;
```
---
class: header_background
#dplyr::pull()
Finally, we discuss the use of the *pull* function to *extract* or *pull out* a variable/column from a data frame. Consider the following code.

```r
flights %&gt;% select(arr_delay)
```

```
## # A tibble: 336,776 x 1
##   arr_delay
##       &lt;dbl&gt;
## 1        11
## 2        20
## 3        33
## 4       -18
## 5       -25
## 6        12
## # … with 336,770 more rows
```

```r
class(flights %&gt;% select(arr_delay))
```

```
## [1] "tbl_df"     "tbl"        "data.frame"
```
---
class: clear

```r
flights %&gt;% pull(arr_delay) %&gt;% head
```

```
## [1]  11  20  33 -18 -25  12
```

```r
class(flights %&gt;% pull(arr_delay))
```

```
## [1] "numeric"
```
--
If we now extract the standard deviation from the above data frame/vector, we get

```r
flights %&gt;% select(arr_delay) %&gt;% sd(na.rm = TRUE)
```

```
## Error in is.data.frame(x): 'list' object cannot be coerced to type 'double'
```

```r
flights %&gt;% pull(arr_delay) %&gt;% sd(na.rm = TRUE)
```

```
## [1] 44.6
```

The difference in the above output is due to the fact that `\(\mathrm{sd}\)` expects a *numeric* vector. Meanwhile, the *select* verb takes as input a *data frame* and ouputs another *data frame*. Since we want to extract the column `\(\mathrm{arr\_delay}\)` ,we need to use `\(\mathrm{pull}\)`. 
---
class: header_background
#summarise + rows vs columns
Continuing the above theme. Suppose we want to find the quantiles for `\(\mathrm{arr\_delay}\)` as grouped by popular destination.
We first try the following code.

```r
pop_dest &lt;- flights %&gt;% 
  group_by(dest) %&gt;% 
  filter(n() &gt; 365,!is.na(arr_delay))
pop_dest %&gt;% summarise(delay_quantile = quantile(arr_delay))
```

```
## # A tibble: 385 x 2
## # Groups:   dest [77]
##   dest  delay_quantile
##   &lt;chr&gt;          &lt;dbl&gt;
## 1 ALB              -34
## 2 ALB              -17
## 3 ALB               -4
## 4 ALB               28
## 5 ALB              328
## 6 ATL              -49
## # … with 379 more rows
```
---
class: clear

The code seems to give a vector of five numbers for each destination. However, in many cases, we prefer to have five new columns but only one row for each destination. Let us first simplify the problem and find the quantiles for 
`\(\mathrm{arr\_delay}\)` for the **ungrouped** data.

```r
pop_dest %&gt;% ungroup() %&gt;% 
  summarise(delay_quantile = quantile(arr_delay))
```

```
## # A tibble: 5 x 1
##   delay_quantile
##            &lt;dbl&gt;
## 1            -86
## 2            -17
## 3             -5
## 4             14
## 5           1272
```

```r
quantile(pop_dest$arr_delay,na.rm = TRUE)
```

```
##   0%  25%  50%  75% 100% 
##  -86  -17   -5   14 1272
```
After some thought (googling?), we realize that **dplyr** verbs takes as input a data frame and outputs another data frame. The output of `\(\mathrm{quantile}\)` is a vector not a data frame. Helper functions to the rescue.
---
class: clear


```r
my_quantile &lt;- function(x){
  z &lt;- quantile(x,na.rm = TRUE)
  names(z) &lt;- c("min","percentile25","median","percentile75","max")
  as_tibble_row(z)
}
pop_dest %&gt;% ungroup() %&gt;% summarise(my_quantile(arr_delay)) 
```

```
## # A tibble: 1 x 5
##     min percentile25 median percentile75   max
##   &lt;dbl&gt;        &lt;dbl&gt;  &lt;dbl&gt;        &lt;dbl&gt; &lt;dbl&gt;
## 1   -86          -17     -5           14  1272
```

```r
pop_dest %&gt;% summarise(my_quantile(arr_delay)) ### Yay!
```

```
## # A tibble: 77 x 6
##   dest    min percentile25 median percentile75   max
##   &lt;chr&gt; &lt;dbl&gt;        &lt;dbl&gt;  &lt;dbl&gt;        &lt;dbl&gt; &lt;dbl&gt;
## 1 ALB     -34        -17       -4         28     328
## 2 ATL     -49        -12       -1         16     895
## 3 AUS     -59        -19       -5         15     349
## 4 BDL     -43        -18      -10         14     266
## 5 BGR     -43        -21.8     -9         19.8   238
## 6 BNA     -58        -15       -2         19     364
## # … with 71 more rows
```
---
class: clear, middle

Finally, compare the previous output with the following

```r
pop_dest %&gt;% 
  summarise(val = quantile(arr_delay), q = c(0, 0.25, 0.5, 0.75,1))
```

```
## # A tibble: 385 x 3
## # Groups:   dest [77]
##   dest    val     q
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 ALB     -34  0   
## 2 ALB     -17  0.25
## 3 ALB      -4  0.5 
## 4 ALB      28  0.75
## 5 ALB     328  1   
## 6 ATL     -49  0   
## # … with 379 more rows
```
&lt;!-- --- --&gt;
&lt;!-- class: clear, middle --&gt;
&lt;!-- Let us now un-un-group the (grouped) data. --&gt;
&lt;!-- ```{r error = TRUE} --&gt;
&lt;!-- pop_dest %&gt;% my_quantile(variable = 'arr_delay') ### Oops! --&gt;
&lt;!-- ``` --&gt;
&lt;!-- Our helper function `\(\mathrm{my\_quantile}\)` does not understand grouped vs ungrouped data. --&gt;
&lt;!-- Luckily, since we "Think and do", after some thinking (googling?) --&gt;
&lt;!-- --- --&gt;
&lt;!-- class: clear --&gt;

&lt;!-- ```{r error = TRUE} --&gt;
&lt;!-- pop_dest %&gt;%  --&gt;
&lt;!--   do(my_quantile(.,variable = 'arr_delay')) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- -- --&gt;
&lt;!-- The help page for [dplyr::do](https://dplyr.tidyverse.org/reference/do.html) reads --&gt;

&lt;!-- ```{r out.width = "70%", echo = FALSE} --&gt;
&lt;!-- knitr::include_graphics("figures/dplyr_do.png") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- See also section 5.12 of [Introduction to Data Science](https://rafalab.github.io/dsbook/tidyverse.html#do) --&gt;
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"highlightSpans": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
