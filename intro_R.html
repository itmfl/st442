<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Introduction to R</title>
    <meta charset="utf-8" />
    <meta name="author" content="Minh Tang" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Introduction to R
## A used-car salesman perspective
### Minh Tang
### Fall 2020

---




#Brief self-introduction
+ Name: Minh Tang. 
+ Birthplace: Vietnam.
+ Degrees: 
    + BS in Computer Science in Thailand. (Prolog, Pascal, Java, C, C++)
    + MS in Computer Science @ U. Wisconsin Milwaukee. (Ruby, Perl, Lisp, More C++)
    + PhD in Computer Science @ Indiana University. (Python, Scheme, OCamL, Haskell, R)
+ Current Affiliation: Department of Statistics @ NCSU.
+ Favorite Quote:
   &gt; Three minutes thought would suffice to find this out but thought is irksome 
   &gt; and three  minutes is a long time.
   &gt; 
   &gt;                     A. E. Houseman


---
#R ? Aarghhh!
&gt; R is a language and environment for statistical computing and graphics. 
&gt; It is a GNU project ...
&gt; R provides a wide variety of statistical (linear and nonlinear modelling,
&gt; classical statistical tests, time-series analysis, classification, clustering, …) 
&gt; and graphical techniques, and is highly extensible. 
&gt;
&gt; https://www.r-project.org/about.html


--
## Q: Why R?

--
## A: Why not R?

---
# The R environment
R is an integrated suite of software facilities for data manipulation, calculation and graphical display. It includes
+ an effective data handling and storage facility,
+ a suite of operators for calculations on arrays, in particular matrices,
+ a large, coherent, integrated collection of intermediate tools for data analysis,
+ graphical facilities for data analysis and display either on-screen or on hardcopy, and
+ a well-developed, simple and effective programming language which includes conditionals, loops, user-defined recursive functions and input and output facilities.
+ effective tools for **literate programming**, e.g., creating a report that seamlessly weave code/data together with formulas, texts, documentation. In fact, these slides are written in *Rmarkdown*.

---
class: clear

+ The term "environment" is intended to characterize it as a fully planned and coherent system, rather than an incremental accretion of very specific and inflexible tools, as is frequently the case with other data analysis software. R can be extended (easily) via packages. 

+ There are about eight packages supplied with the R distribution and many more (&gt;10,000) 
are available through the CRAN family of Internet sites.

---
# Resources for learning R

+ R-project [An Introduction to R](https://cran.r-project.org/doc/manuals/r-release/R-intro.pdf)

+ Roger Peng's [R Programming for Data Science](https://bookdown.org/rdpeng/rprogdatascience/)

+ Rafael Irizarry's [Introduction to Data Science](https://rafalab.github.io/dsbook/)

+ [JHU Coursera](https://www.coursera.org/learn/r-programming)

+ Yihui Xie, J. Allaire and Garrett Grolemund [Rmarkdown definitive guide](https://bookdown.org/yihui/rmarkdown/)

+ Long and Teetor [R Cookbook](https://rc2e.com/)

+ Garrett Grolemund and Hadley Wickham, [R for Data Science](https://r4ds.had.co.nz)

+ Benjamin Baumer, Daniel Kaplan, and Nicholas Horton, [Modern Data Science with R](https://beanumber.github.io/mdsr2e/)

--
+ `?` in **R**
&lt;br&gt;

--
+ [Google it!](https://lmgtfy.com/?q=advanced+google+search+tips)


---
#Overview of lecture
&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://bit.ly/2CV35vJ" alt="https://r4ds.had.co.nz" width="70%" /&gt;
&lt;p class="caption"&gt;https://r4ds.had.co.nz&lt;/p&gt;
&lt;/div&gt;

We will cover the following topics
+ Basics of **R** programming.
+ Data wrangling and tidying with dplyr (**R** library)
+ Data visualization with ggplot2 (**R** library)

---
#The many vectors of R

.pull-left[
&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://d33wubrfki0l68.cloudfront.net/1d1b4e1cf0dc5f6e80f621b0225354b0addb9578/6ee1c/diagrams/data-structures-overview.png" alt="Hierarchy of R's vector type (https://r4ds.had.co.nz/vectors.html)" width="125%" /&gt;
&lt;p class="caption"&gt;Hierarchy of R's vector type (https://r4ds.had.co.nz/vectors.html)&lt;/p&gt;
&lt;/div&gt;
]
.pull-right[
+ Atomic vectors are homogeneous (all elements are the same type)
+ Lists (or recursive vectors) can be heterogeneous (elements can be of different type)
+ `\(\mathrm{NULL}\)` represents vector of length `\(0\)`. 
]
---
class: clear
Every vector in **R** has two key properties.

.pull-left[
+ type: determine via **typeof()**

```r
typeof(c("A","B","C"))
```

```
## [1] "character"
```

```r
typeof(1:10)
```

```
## [1] "integer"
```

```r
library(nycflights13)
typeof(flights)
```

```
## [1] "list"
```

```r
typeof(NULL)
```

```
## [1] "NULL"
```
]
.pull-right[ 
+ length: determine via **length()**

```r
length(letters)
```

```
## [1] 26
```

```r
length(1:10)
```

```
## [1] 10
```

```r
length(flights)
```

```
## [1] 19
```

```r
length(NULL)
```

```
## [1] 0
```
]

---
#Important type of atomic vectors

Vectors are created in **R** using the function `\(\mathtt{c()}\)` for combine.

+ Logical: simplest type of vector. Three values ( `\(\mathtt{TRUE}\)`, `\(\mathtt{FALSE}\)` and `\(\mathtt{NA}\)`).

```r
c(TRUE, FALSE, FALSE, NA, T, F)
```

```
## [1]  TRUE FALSE FALSE    NA  TRUE FALSE
```

+ Numeric: vectors whose elements are integers or doubles. Numbers are doubles by default.
Note that doubles representation are only approximations.

```r
c(typeof(1), typeof(1L), typeof(1.5L))
```

```
## [1] "double"  "integer" "double"
```
.pull-left[

```r
x &lt;- sqrt(2)^2; x; x - 2
```

```
## [1] 2
```

```
## [1] 4.44e-16
```
]
.pull-right[

```r
c(x == 2, dplyr::near(x,2))
```

```
## [1] FALSE  TRUE
```
]

---
class: clear
+ Special values (avoid using `\(==\)` to check for special values)
    + `\(\mathtt{NA}\)`: integer and double; check with `\(\mathtt{is.na}\)` 
    + `\(\mathtt{Inf}\)` and `\(-\mathtt{Inf}\)`: double; check with `\(\mathtt{is.infinite()}\)`       
    + `\(\mathtt{NaN}\)`: double; check with `\(\mathtt{is.nan()}\)` or `\(\mathtt{is.na()}\)`.

```r
c(-1,0,1)/0
```

```
## [1] -Inf  NaN  Inf
```

```r
NA*(c(-1,0,1)/0)
```

```
## [1]  NA NaN  NA
```

+ Characters: each element of a character vector is itself a string. 

```r
x &lt;- c("A string","A longer string", "Even longer string")
typeof(x); length(x)
```

```
## [1] "character"
```

```
## [1] 3
```
---
class: clear

+ The types are, from least to most general, 
$$ \mathtt{logical} \rightarrow \underbrace{\mathtt{integer} \rightarrow \mathtt{double}}_{\mathtt{numeric}} \rightarrow  \mathtt{character} $$
+ Explicit coercion is via: `\(\mathtt{as.logical()}\)`, `\(\mathtt{as.numeric()}\)`, `\(\mathtt{as.integer()}\)`, `\(\mathtt{as.double()}\)`, `\(\mathtt{as.character()}\)`. 

+ Implicit coercion: `\(\mathtt{TRUE}\)` and `\(\mathtt{FALSE}\)` are coerced to `\(1\mathrm{L}\)` and `\(0\mathrm{L}\)`. On occasions, positive integer is coerced to `\(\mathtt{TRUE}\)` and `\(0\)` is coerced to `\(\mathtt{FALSE}\)`

```r
x &lt;- 3
if(length(x)){
  x &lt;- rep(x, 2)
}
x
```

```
## [1] 3 3
```

---
class: clear

+ All atomic vectors need to be of the same type, e.g.,

```r
typeof(c(TRUE, 1L))
```

```
## [1] "integer"
```

```r
typeof(c(1L,1))
```

```
## [1] "double"
```

```r
typeof(c("1",1))
```

```
## [1] "character"
```
---
#Vector recycling rules
Basic mathematical operations are vectorized in **R**. In the case where the vectors appearing in the operations are not of the same length, **R** will automatically recycle/repeated the shorter vector to be of the same length as the longer vector (with a possible warning message)

```r
1:10 + 1
```

```
##  [1]  2  3  4  5  6  7  8  9 10 11
```

```r
1:10 + 1:2
```

```
##  [1]  2  4  4  6  6  8  8 10 10 12
```

```r
1:10 + 1:3
```

```
## Warning in 1:10 + 1:3: longer object length is not a multiple of shorter object
## length
```

```
##  [1]  2  4  6  5  7  9  8 10 12 11
```
---
class: clear
For explicit recycling/repetition, use `\(\mathtt{rep()}\)`, e.g.,

```r
rep(1:2, times = 5)
```

```
##  [1] 1 2 1 2 1 2 1 2 1 2
```

```r
rep(1:2, each = 5)
```

```
##  [1] 1 1 1 1 1 2 2 2 2 2
```

```r
rep(1:3, times = c(2,3,4))
```

```
## [1] 1 1 2 2 2 3 3 3 3
```

---
# Naming elements of a vector

```r
c(x = 1,y = 2, z = 3)
```

```
## x y z 
## 1 2 3
```

```r
w &lt;- c(1,2,3)
names(w) &lt;- c("x", "y", "z")
w
```

```
## x y z 
## 1 2 3
```

---
#Subsetting elements of a vector
Vectors are subset in **R** using the `[` function. There are four type of things that can appear within `[`
+ A numeric vector containing only integers. The integers must either be **all** non-negative or **all** non-positive

.pull-left[

```r
x &lt;- 1:10
x[c(3,2,5)]
```

```
## [1] 3 2 5
```

```r
x[c(3,3,2,5,5)]
```

```
## [1] 3 3 2 5 5
```
]

.pull-right[

```r
x[0]
```

```
## integer(0)
```

```r
x[c(0,-2,-4)]
```

```
## [1]  1  3  5  6  7  8  9 10
```
]


```r
x[c(1,-2,-4)]
```

```
## Error in x[c(1, -2, -4)]: only 0's may be mixed with negative subscripts
```
---
class: clear
+ Subsetting with a logical vector `\(v\)` keeps **all** values corresponding to a `\(\mathtt{TRUE}\)` value in `\(v\)` (and add missing values if there are missing values in `\(v\)`) e.g.,

```r
x%%2 == 0
```

```
##  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE
```

```r
x[x%%2 == 0]
```

```
## [1]  2  4  6  8 10
```

```r
x[c(TRUE, FALSE, NA, FALSE, TRUE)]
```

```
## [1]  1 NA  5  6 NA 10
```
---
class: clear

+ We can use `\(\mathtt{which}\)` to determine the indices of a logical vector with `\(\mathtt{TRUE}\)` values, e.g.,

```r
which(x %% 2 == 0)
```

```
## [1]  2  4  6  8 10
```

```r
which(c(TRUE, FALSE, NA, FALSE, TRUE))
```

```
## [1] 1 5
```

+ If the vector has names then you can subset it with a character vector, e.g.,

```r
w &lt;- c(x = 1, y = 2, z = 3)
w[c("x","z","z","x")]
```

```
## x z z x 
## 1 3 3 1
```
---
class: clear
+ Finally, you can extract all the elements with `[]` or a single element with `[[]]`, e.g.,

```r
x &lt;- 1:10
x[]
```

```
##  [1]  1  2  3  4  5  6  7  8  9 10
```

```r
x[[1]]
```

```
## [1] 1
```

```r
x[[c(1,2)]]
```

```
## Error in x[[c(1, 2)]]: attempt to select more than one element in vectorIndex
```
---
#Recursive vectors (lists)
Lists are non-atomic vectors whose elements are themselves possibly other lists. Thus, the elements of a list could have different type, e.g.,

.pull-left[

```r
u &lt;- list(1,2,3)
u
```

```
## [[1]]
## [1] 1
## 
## [[2]]
## [1] 2
## 
## [[3]]
## [1] 3
```

```r
v &lt;- list(c(1,2,3))
v
```

```
## [[1]]
## [1] 1 2 3
```
]
.pull-right[

```r
x &lt;- list(1,2,"NA")
x
```

```
## [[1]]
## [1] 1
## 
## [[2]]
## [1] 2
## 
## [[3]]
## [1] "NA"
```

```r
y &lt;- list(c(1,2,"NA"))
y
```

```
## [[1]]
## [1] "1"  "2"  "NA"
```
]
---
class: clear

```r
w &lt;- list(u,v,x,y)
length(w)
```

```
## [1] 4
```

```r
str(w)
```

```
## List of 4
##  $ :List of 3
##   ..$ : num 1
##   ..$ : num 2
##   ..$ : num 3
##  $ :List of 1
##   ..$ : num [1:3] 1 2 3
##  $ :List of 3
##   ..$ : num 1
##   ..$ : num 2
##   ..$ : chr "NA"
##  $ :List of 1
##   ..$ : chr [1:3] "1" "2" "NA"
```
---
#Extracting elements from a list

```r
a &lt;- list(a = 1:3, b = "a string", c = pi, d = list(-1, -5))
str(a)
```

```
## List of 4
##  $ a: int [1:3] 1 2 3
##  $ b: chr "a string"
##  $ c: num 3.14
##  $ d:List of 2
##   ..$ : num -1
##   ..$ : num -5
```

There are three ways to subset a list, namely `[`, `[[` and `$`.
+ `[` will always extract a sub-list and hence returns another list.
.pull-left[

```r
str(a[1:2])
```

```
## List of 2
##  $ a: int [1:3] 1 2 3
##  $ b: chr "a string"
```
]
.pull-right[

```r
str(a[4])
```

```
## List of 1
##  $ d:List of 2
##   ..$ : num -1
##   ..$ : num -5
```
]

---
class: clear
+ `[[` will always extract a **single element** from a list and 
hence removes a level of nesting. 

.pull-left[

```r
str(a[[4]])
```

```
## List of 2
##  $ : num -1
##  $ : num -5
```

```r
a[[c(4,1)]]
```

```
## [1] -1
```

```r
a[[4]][[1]] ## Equivalent to the above
```

```
## [1] -1
```

```r
a[[4]][1] #Not equivalent to the above
```

```
## [[1]]
## [1] -1
```
]

.pull-right[

```r
a[[1:2]] ## Recursive indexing
```

```
## [1] 2
```

```r
a[[1:3]]
```

```
## Error in a[[1:3]]: recursive indexing failed at level 2
```
]

---
class: clear
+ `$` will always extract a **single named element** from a list.

```r
str(a$d)
```

```
## List of 2
##  $ : num -1
##  $ : num -5
```

```r
str(a[["d"]])
```

```
## List of 2
##  $ : num -1
##  $ : num -5
```

```r
str(a["d"])
```

```
## List of 1
##  $ d:List of 2
##   ..$ : num -1
##   ..$ : num -5
```

---
class: clear
&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="https://d33wubrfki0l68.cloudfront.net/2f3f752cae25018554d484464f117e600ff365a2/37627/diagrams/lists-subsetting.png" alt="Section 20.5 of R4DS" width="70%" /&gt;
&lt;p class="caption"&gt;Section 20.5 of R4DS&lt;/p&gt;
&lt;/div&gt;
---
#Vectors and attributes
Any vector can contain arbitrary metadata through its attributes. Attributes allows us to implement quite a few fancy data structures using the base **R** vectors. For example
.pull-left[

```r
x &lt;- c(1L, 2L, 3L); x
```

```
## [1] 1 2 3
```

```r
typeof(x); attributes(x)
```

```
## [1] "integer"
```

```
## NULL
```
]
.pull-right[

```r
class(x) &lt;- "Date"; x
```

```
## [1] "1970-01-02" "1970-01-03" "1970-01-04"
```

```r
typeof(x); attributes(x)
```

```
## [1] "integer"
```

```
## $class
## [1] "Date"
```

```r
attr(x,"Greetings") &lt;- "Welcome to 442"
attributes(x)
```

```
## $class
## [1] "Date"
## 
## $Greetings
## [1] "Welcome to 442"
```
]

---
class: clear

.pull-left[

```r
y &lt;- 1:6; y
```

```
## [1] 1 2 3 4 5 6
```

```r
typeof(y); attributes(y)
```

```
## [1] "integer"
```

```
## NULL
```

```r
names(y) &lt;- c("M","T","W",
              "Th","F","Sat")
y
```

```
##   M   T   W  Th   F Sat 
##   1   2   3   4   5   6
```

```r
attributes(y)
```

```
## $names
## [1] "M"   "T"   "W"   "Th"  "F"   "Sat"
```
]
.pull-right[

```r
 ## similar to dim(y) &lt;- c(3,2)
attr(y, "dim") &lt;- c(3,2)
y
```

```
##      [,1] [,2]
## [1,]    1    4
## [2,]    2    5
## [3,]    3    6
## attr(,"names")
## [1] "M"   "T"   "W"   "Th"  "F"   "Sat"
```

```r
y["M"]
```

```
## M 
## 1
```

```r
typeof(y); attributes(y)
```

```
## [1] "integer"
```

```
## $names
## [1] "M"   "T"   "W"   "Th"  "F"   "Sat"
## 
## $dim
## [1] 3 2
```
]
---
class: clear

The three most important attributes of a vector are
+ **names** for naming the elements
+ **dimensions** or dims to make a vector behave like a matrix or aray
+ **class** is for implementing the S3 object-oriented system (see Hadley's Wickham [Advanced R](https://adv-r.hadley.nz/oo.html) for the gory details of **R** numerous objected-oriented systems).

Attributed vectors are used to implement *factors*, dates and times and data frames.
---
#Data frames
A data frame (in base **R**) is then simply a list whose elements are vectors, each of the same length. Consider the following `\(\mathtt{mtcars}\)` data frame.


```r
head(mtcars)
```

```
## # A tibble: 6 x 11
##     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1  21       6   160   110  3.9   2.62  16.5     0     1     4     4
## 2  21       6   160   110  3.9   2.88  17.0     0     1     4     4
## 3  22.8     4   108    93  3.85  2.32  18.6     1     1     4     1
## 4  21.4     6   258   110  3.08  3.22  19.4     1     0     3     1
## 5  18.7     8   360   175  3.15  3.44  17.0     0     0     3     2
## 6  18.1     6   225   105  2.76  3.46  20.2     1     0     3     1
```

```r
typeof(mtcars)
```

```
## [1] "list"
```
---
class: clear

```r
length(mtcars)
```

```
## [1] 11
```

```r
str(mtcars)
```

```
## 'data.frame':	32 obs. of  11 variables:
##  $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...
##  $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...
##  $ disp: num  160 160 108 258 360 ...
##  $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...
##  $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
##  $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...
##  $ qsec: num  16.5 17 18.6 19.4 17 ...
##  $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...
##  $ am  : num  1 1 1 0 0 0 0 0 0 0 ...
##  $ gear: num  4 4 4 3 3 3 3 4 4 4 ...
##  $ carb: num  4 4 1 1 2 1 4 2 2 4 ...
```
---
class: clear

```r
attributes(mtcars)
```

```
## $names
##  [1] "mpg"  "cyl"  "disp" "hp"   "drat" "wt"   "qsec" "vs"   "am"   "gear"
## [11] "carb"
## 
## $row.names
##  [1] "Mazda RX4"           "Mazda RX4 Wag"       "Datsun 710"         
##  [4] "Hornet 4 Drive"      "Hornet Sportabout"   "Valiant"            
##  [7] "Duster 360"          "Merc 240D"           "Merc 230"           
## [10] "Merc 280"            "Merc 280C"           "Merc 450SE"         
## [13] "Merc 450SL"          "Merc 450SLC"         "Cadillac Fleetwood" 
## [16] "Lincoln Continental" "Chrysler Imperial"   "Fiat 128"           
## [19] "Honda Civic"         "Toyota Corolla"      "Toyota Corona"      
## [22] "Dodge Challenger"    "AMC Javelin"         "Camaro Z28"         
## [25] "Pontiac Firebird"    "Fiat X1-9"           "Porsche 914-2"      
## [28] "Lotus Europa"        "Ford Pantera L"      "Ferrari Dino"       
## [31] "Maserati Bora"       "Volvo 142E"         
## 
## $class
## [1] "data.frame"
```

---
# Automation and iteration
Compare the following code chunks.
.pull-left[

```r
df &lt;- data.frame(
  a = rnorm(100),
  b = rnorm(100),
  c = rnorm(100),
  d = rnorm(100)
)
output &lt;- numeric(length(df))
for(i in 1:length(df)){
  output[i] &lt;- median(df[[i]])
}
output
```

```
## [1]  0.0442 -0.1212 -0.0989  0.0833
```

```r
apply(df,2,median)
```

```
##       a       b       c       d 
##  0.0442 -0.1212 -0.0989  0.0833
```
]

.pull-right[

```r
lapply(df,median)
```

```
## $a
## [1] 0.0442
## 
## $b
## [1] -0.121
## 
## $c
## [1] -0.0989
## 
## $d
## [1] 0.0833
```

```r
sapply(df,median)
```

```
##       a       b       c       d 
##  0.0442 -0.1212 -0.0989  0.0833
```
]
---
class: clear
The **apply** family of operations allow for complex iterations over elements of a data frame, list, or matrix, without the need to write explicit loops construct. For example,

.pull-left[

```r
probs = c(0.25,0.5,0.75)
output2 &lt;- matrix(0, length(probs), 
                     length(df))
for(i in seq_along(df)){
  output2[,i] &lt;- quantile(df[[i]], 
                          probs)
}
output2
```

```
##         [,1]   [,2]    [,3]    [,4]
## [1,] -0.6642 -0.820 -0.5683 -0.5894
## [2,]  0.0442 -0.121 -0.0989  0.0833
## [3,]  0.6350  0.575  0.5307  0.7890
```
]

.pull-right[

```r
apply(df, 2, quantile, probs)
```

```
##           a      b       c       d
## 25% -0.6642 -0.820 -0.5683 -0.5894
## 50%  0.0442 -0.121 -0.0989  0.0833
## 75%  0.6350  0.575  0.5307  0.7890
```

```r
sapply(df, quantile, probs)
```

```
##           a      b       c       d
## 25% -0.6642 -0.820 -0.5683 -0.5894
## 50%  0.0442 -0.121 -0.0989  0.0833
## 75%  0.6350  0.575  0.5307  0.7890
```
]
---
class: clear

There are numerous variants of *apply*, including

+ `\(\mathrm{apply}(X, \mathrm{margin}, \mathrm{FUN}, ...)\)` which takes a data frame, array or matrix `\(X\)` and returns a vector/array/list of values obtained by applying `\(\mathrm{FUN}\)` to the margins (e.g., rows and columns) of `\(X\)`. 

+ `\(\mathrm{lapply}(X, \mathrm{FUN}, ...)\)` which takes a list `\(X\)` and return a list of the same length as `\(X\)`, each element of which is the result of applying `\(\mathrm{FUN}\)` to the corresponding element of `\(X\)`.

+ `\(\mathrm{sapply}(X, \mathrm{FUN}, ...)\)` is a user-friendly wrapper of `\(\mathrm{lapply}\)` that try to return a vector, matrix, or array, if possible.

+ `\(\mathrm{mapply}(\mathrm{FUN}, ..., \mathrm{MoreArgs})\)` is a multivariate version of `\(\mathrm{sapply}\)`; `\(\mathrm{mapply}\)` applies FUN to the first elements of each `\(...\)` argument, the second elements, the third elements, and so on.

+ `\(\mathrm{tapply}(X, \mathrm{INDEX}, \mathrm{FUN} = \mathrm{NULL}, ...)\)` apply `\(\mathrm{FUN}\)` to each (non-empty) group of values of `\(X\)` given by a unique combination of the levels of factors contained in the list `\(\mathrm{INDEX}\)`

---
class: clear
The following are some examples of *apply* and its variants.


```r
# ?beaver1 and ?beaver2
beaver &lt;- list(beaver1 = beaver1, beaver2 = beaver2)
lapply(beaver, function(x) apply(x,2,mean))
```

```
## $beaver1
##      day     time     temp    activ 
## 3.46e+02 1.31e+03 3.69e+01 5.26e-02 
## 
## $beaver2
##     day    time    temp   activ 
##  307.13 1446.20   37.60    0.62
```

```r
sapply(beaver, function(x) apply(x,2,mean))
```

```
##        beaver1 beaver2
## day   3.46e+02  307.13
## time  1.31e+03 1446.20
## temp  3.69e+01   37.60
## activ 5.26e-02    0.62
```

---
class: clear


```r
## Version that does not use anonymous functions
beaver_fn &lt;- function(x){
  apply(x,2,mean) ## Automatically return the output from the last statement
}

lapply(beaver, beaver_fn)
```

```
## $beaver1
##      day     time     temp    activ 
## 3.46e+02 1.31e+03 3.69e+01 5.26e-02 
## 
## $beaver2
##     day    time    temp   activ 
##  307.13 1446.20   37.60    0.62
```

+ For more on writing functions in **R**, see [this note](http://homepage.divms.uiowa.edu/~luke/R/references.html) and [that note](http://adv-r.had.co.nz/Functions.html). 

+ In particular, **R** uses pass-by-values in its function calls. 

+ For more on automation and iteration, see [here](https://beanumber.github.io/mdsr2e/ch-iteration.html)


---
# Data Wrangling with R
We introduce the **dplyr** package written by Hadley Wickham, Roman Fran&amp;ccedil;ois, Lionel Henry, and Kirill M&amp;uuml;ller. This package is a core member of the **tidyverse** approach to data manipulation; the tidyverse provides a coherent framework for reading, pre-processing/wrangling, visualizing, and modeling data.

There are five main important *verbs* associated with dplyr, namely

+ *filter*
+ *select*
+ *mutate* and *transmute*
+ *group_by* and *summarize*

**NB** You can also use dplyr with SQL databases through the package [dbplyr](https://cran.r-project.org/web/packages/dbplyr/vignettes/dbplyr.html). Note, however, that the performance might be worse than writing your own **optimized** SQL queries.

---
class: clear
We shall follow an an abbreviated presentation from Chapter 5 of [R for data science](https://r4ds.had.co.nz/). We first load the *flights13* dataset from the **nycflights13** package. This dataset describe the on-time data for all flights departing from NYC airports (i.e. JFK, LGA or EWA) in 2013.


```r
library(tidyverse)
library(nycflights13)
data(flights)
flights
```

```
## # A tibble: 336,776 x 19
##    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
## 1  2013     1     1      517            515         2      830            819
## 2  2013     1     1      533            529         4      850            830
## 3  2013     1     1      542            540         2      923            850
## 4  2013     1     1      544            545        -1     1004           1022
## 5  2013     1     1      554            600        -6      812            837
## 6  2013     1     1      554            558        -4      740            728
## # … with 336,770 more rows, and 11 more variables: arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;,
## #   air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;
```
---
#filter()
Let us find flights departing NYC on August 21. Note that **dplyr** verbs takes a data frame and return a new data frame.

```r
filter(flights, month == 8, day == 21)
```

```
## # A tibble: 990 x 19
##    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
## 1  2013     8    21       10           2359        11      350            344
## 2  2013     8    21       36           2359        37      413            350
## 3  2013     8    21       48           1620       508      251           1902
## 4  2013     8    21      453            500        -7      634            642
## 5  2013     8    21      528            530        -2      757            801
## 6  2013     8    21      536            545        -9      808            816
## # … with 984 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;,
## #   flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;
```

```r
## Equivalently: filter(flights, month == 8 &amp; day == 21)
```
---
class: clear
Next, let us try to filter flights from August 21, 2013 that departs from either JFK or LGA.

```r
august21 &lt;- filter(flights, month == 8 &amp; day == 21)
filter(august21, origin == 'JFK' | origin == 'LGA') 
```

```
## # A tibble: 637 x 19
##    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
## 1  2013     8    21       10           2359        11      350            344
## 2  2013     8    21       36           2359        37      413            350
## 3  2013     8    21       48           1620       508      251           1902
## 4  2013     8    21      536            545        -9      808            816
## 5  2013     8    21      540            540         0      837            840
## 6  2013     8    21      544            545        -1      911            921
## # … with 631 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;,
## #   flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;
```

```r
## Equivalently: filter(august21, origin %in% c("JFK","LGA"))
```
---
class: clear
Let us now check, among all the flights on August 21 from either JFK or LGA, which of them has a departure or arrival delay of 10 minutes or more.

```r
august21_jfk_lga &lt;- filter(august21, origin %in% c("JFK","LGA"))
filter(august21_jfk_lga, arr_delay &gt; 10 | dep_delay &gt; 10)
```

```
## # A tibble: 106 x 19
##    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
## 1  2013     8    21       10           2359        11      350            344
## 2  2013     8    21       36           2359        37      413            350
## 3  2013     8    21       48           1620       508      251           1902
## 4  2013     8    21      555            600        -5      839            826
## 5  2013     8    21      558            600        -2      830            815
## 6  2013     8    21      625            600        25      903            851
## # … with 100 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;,
## #   flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;
```

Missing values are represented in **R** as `\(\mathrm{NA}\)`; missing values are "contagious" hence any almost all operations involving one or more `\(\mathrm{NA}\)` will also return a `\(\mathrm{NA}\)`. This has **very important** consequences when you filter data. See section 5.2.3 of [R for data science](https://r4ds.had.co.nz/).
---
# Pipes

We can do all of the above filtering using a single chain sequence as follows

```r
flights %&gt;% filter(month == 8 &amp; day == 21) %&gt;% 
            filter(origin %in% c("JFK","LGA")) %&gt;%
            filter(arr_delay &gt; 10 | dep_delay &gt; 10)
```

```
## # A tibble: 106 x 19
##    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
## 1  2013     8    21       10           2359        11      350            344
## 2  2013     8    21       36           2359        37      413            350
## 3  2013     8    21       48           1620       508      251           1902
## 4  2013     8    21      555            600        -5      839            826
## 5  2013     8    21      558            600        -2      830            815
## 6  2013     8    21      625            600        25      903            851
## # … with 100 more rows, and 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;,
## #   flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;
```

The previous example introduce the use of the `\(\%&gt;\%\)` pipe operator. 
The pipe operator allows us an elegant way to chain together a sequence of operations without the need to introduce auxiliary variables.
The pipe operator maps `\(x \%&gt;\% f(y)\)` to `\(f(x,y)\)`. 

---
#arrange()
The *arrange* verb is similar to the *filter* verb, but instead of selecting rows, it reorder them according to some set of column names (or more complicated expressions). As an example, let us order the flights first by the three letter code for the airport destination, then by the date of flight.

```r
flights_dest &lt;- select(flights, dest, everything()) 
arrange(flights_dest, dest, month, day)
```

```
## # A tibble: 336,776 x 19
##   dest   year month   day dep_time sched_dep_time dep_delay arr_time
##   &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
## 1 ABQ    2013     4    22     1712           1630        42     1946
## 2 ABQ    2013     4    23     2022           2025        -3     2319
## 3 ABQ    2013     4    24     2037           2025        12       14
## 4 ABQ    2013     4    25     2023           2025        -2     2339
## 5 ABQ    2013     4    26     2020           2025        -5     2318
## 6 ABQ    2013     4    27     2020           2025        -5     2245
## # … with 336,770 more rows, and 11 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;
```
---
class: clear
We can use **desc** to order a column in descending order, e.g.,

```r
arrange(flights_dest, desc(dest), month, day)
```

```
## # A tibble: 336,776 x 19
##   dest   year month   day dep_time sched_dep_time dep_delay arr_time
##   &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
## 1 XNA    2013     1     1      656            705        -9     1007
## 2 XNA    2013     1     1     1525           1530        -5     1934
## 3 XNA    2013     1     1     1740           1745        -5     2158
## 4 XNA    2013     1     2      656            705        -9     1014
## 5 XNA    2013     1     2      905            822        43     1313
## 6 XNA    2013     1     2     1531           1530         1     1846
## # … with 336,770 more rows, and 11 more variables: sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;
```
---
#select()
This verb is used to select a subset of columns (of variables). As an example, let us keep only the departure and arrival time of the flights.

```r
flights_sml &lt;- select(flights, year, month, day, 
                      dep_time, sched_dep_time, 
                      arr_time, sched_arr_time)
flights_sml
```

```
## # A tibble: 336,776 x 7
##    year month   day dep_time sched_dep_time arr_time sched_arr_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;    &lt;int&gt;          &lt;int&gt;
## 1  2013     1     1      517            515      830            819
## 2  2013     1     1      533            529      850            830
## 3  2013     1     1      542            540      923            850
## 4  2013     1     1      544            545     1004           1022
## 5  2013     1     1      554            600      812            837
## 6  2013     1     1      554            558      740            728
## # … with 336,770 more rows
```
---
class: clear
There are a few equivalent way to do the above selection, e.g.,

```r
names(flights)
```

```
##  [1] "year"           "month"          "day"            "dep_time"      
##  [5] "sched_dep_time" "dep_delay"      "arr_time"       "sched_arr_time"
##  [9] "arr_delay"      "carrier"        "flight"         "tailnum"       
## [13] "origin"         "dest"           "air_time"       "distance"      
## [17] "hour"           "minute"         "time_hour"
```

```r
## flights_sml &lt;- select(flights, year:day, dep_time, 
##                       sched_dep_time, arr_time, sched_arr_time)
## flights_sml &lt;- select(flights, year:day, contains("dep_time"),
##                       contains("arr_time"))
## flights_sml &lt;- select(flights, year:day, contains("time"),
##                      -c(air_time,time_hour))
```
---
class: clear
We can also rename variables using *select*; however this will lead to the dropping of variables that are not explicitly mentioned. A better alternative is to use *rename*, e.g.,

```r
rename(flights_sml,
       departure_time = dep_time, arrival_time = arr_time)
```

```
## # A tibble: 336,776 x 7
##    year month   day departure_time sched_dep_time arrival_time sched_arr_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;          &lt;int&gt;          &lt;int&gt;        &lt;int&gt;          &lt;int&gt;
## 1  2013     1     1            517            515          830            819
## 2  2013     1     1            533            529          850            830
## 3  2013     1     1            542            540          923            850
## 4  2013     1     1            544            545         1004           1022
## 5  2013     1     1            554            600          812            837
## 6  2013     1     1            554            558          740            728
## # … with 336,770 more rows
```
---
class: clear
A useful helper function for use with select is the **everything()** function, which matches all variables, e.g., to move a specific variable to the first column of data frame, we can do

```r
select(flights_sml, dep_time, everything())
```

```
## # A tibble: 336,776 x 7
##   dep_time  year month   day sched_dep_time arr_time sched_arr_time
##      &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;          &lt;int&gt;    &lt;int&gt;          &lt;int&gt;
## 1      517  2013     1     1            515      830            819
## 2      533  2013     1     1            529      850            830
## 3      542  2013     1     1            540      923            850
## 4      544  2013     1     1            545     1004           1022
## 5      554  2013     1     1            600      812            837
## 6      554  2013     1     1            558      740            728
## # … with 336,770 more rows
```
---
# mutate()
The *mutate* verb is used to add new columns (that are possibly functions of existing columns) to a data frame; the new columns are always added as the last columns. 

```r
flights_sml &lt;- select(flights, year:day,ends_with("delay"),
                      distance, air_time)
mutate(flights_sml, gain = arr_delay - dep_delay,
                    hours = air_time/60,
                    speed = distance/hours,
                    gain_per_hour = gain/hours) %&gt;% select(-hours)
```

```
## # A tibble: 336,776 x 10
##    year month   day dep_delay arr_delay distance air_time  gain speed
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1  2013     1     1         2        11     1400      227     9  370.
## 2  2013     1     1         4        20     1416      227    16  374.
## 3  2013     1     1         2        33     1089      160    31  408.
## 4  2013     1     1        -1       -18     1576      183   -17  517.
## 5  2013     1     1        -6       -25      762      116   -19  394.
## 6  2013     1     1        -4        12      719      150    16  288.
## # … with 336,770 more rows, and 1 more variable: gain_per_hour &lt;dbl&gt;
```
---
class: clear
A variant of *mutate* is *transmute*, which drops all variables except the newly created variables, e.g.,

```r
transmute(flights, gain = arr_delay - dep_delay, 
                   hours = air_time/60, 
                   gain_per_hour = gain/hours)
```

```
## # A tibble: 336,776 x 3
##    gain hours gain_per_hour
##   &lt;dbl&gt; &lt;dbl&gt;         &lt;dbl&gt;
## 1     9  3.78          2.38
## 2    16  3.78          4.23
## 3    31  2.67         11.6 
## 4   -17  3.05         -5.57
## 5   -19  1.93         -9.83
## 6    16  2.5           6.4 
## # … with 336,770 more rows
```
---
#summarize()
The *summarize* verb collapses a data frame to a single row. For example

```r
summarize(flights, delay = mean(dep_delay)) ## oops! missing values
```

```
## # A tibble: 1 x 1
##   delay
##   &lt;dbl&gt;
## 1    NA
```

```r
summarize(flights, delay = mean(dep_delay, na.rm = TRUE))
```

```
## # A tibble: 1 x 1
##   delay
##   &lt;dbl&gt;
## 1  12.6
```
---
class: clear
This is not terribly exciting. The power of *summarize* comes from its combination with **groub_by()**, allowing us to do *grouped summaries*, i.e., summary statistics on individual groups. For example

```r
flights %&gt;% dplyr::group_by(year, month, day)
```

```
## # A tibble: 336,776 x 19
##    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
## 1  2013     1     1      517            515         2      830            819
## 2  2013     1     1      533            529         4      850            830
## 3  2013     1     1      542            540         2      923            850
## 4  2013     1     1      544            545        -1     1004           1022
## 5  2013     1     1      554            600        -6      812            837
## 6  2013     1     1      554            558        -4      740            728
## # … with 336,770 more rows, and 11 more variables: arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;,
## #   air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;
```
---
class: clear

```r
flights %&gt;% group_by(year, month, day) %&gt;%
summarize(delay = mean(dep_delay, na.rm = TRUE))
```

```
## # A tibble: 365 x 4
##    year month   day delay
##   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;
## 1  2013     1     1 11.5 
## 2  2013     1     2 13.9 
## 3  2013     1     3 11.0 
## 4  2013     1     4  8.95
## 5  2013     1     5  5.73
## 6  2013     1     6  7.15
## # … with 359 more rows
```
---
class: clear
A more involved example is to compute the average distance and delay for flights to all destinations (except Honolulu).

```r
delays &lt;- flights %&gt;% group_by(dest) %&gt;% 
  summarize(count = n(), 
            dist = mean(distance,na.rm = TRUE),
            avg_delay = mean(arr_delay + dep_delay,na.rm = TRUE)
            ) %&gt;%
  filter(count &gt; 20, dest != "HNL")
delays
```

```
## # A tibble: 96 x 4
##   dest  count  dist avg_delay
##   &lt;chr&gt; &lt;int&gt; &lt;dbl&gt;     &lt;dbl&gt;
## 1 ABQ     254 1826       18.1
## 2 ACK     265  199       11.3
## 3 ALB     439  143       37.8
## 4 ATL   17215  757.      23.7
## 5 AUS    2439 1514.      19.0
## 6 AVL     275  584.      16.2
## # … with 90 more rows
```
---
class: clear

We can then plot how the average delay varies with the distance.

```r
library(ggplot2)
ggplot(delays, aes(x = dist, y  = avg_delay)) + 
  geom_point(aes(size = count)) +
  geom_smooth(se = FALSE) + ylab("average delay") + theme_classic()
```

&lt;img src="intro_R_files/figure-html/unnamed-chunk-63-1.png" width="80%" style="display: block; margin: auto;" /&gt;
---
class: clear
There are a large number of useful summary functions. See Section 5.6.4 of [R4DS](https://r4ds.had.co.nz/transform.html#summarise-funs). We provide a few more examples.

```r
## average arrival delay
not_canceled &lt;- filter(flights, !is.na(dep_delay) &amp; !is.na(arr_delay))
not_canceled %&gt;% group_by(year, month, day) %&gt;% 
  summarize(avg_delay = mean(arr_delay), 
            avg_positive_delay = mean(arr_delay[arr_delay &gt; 0]))
```

```
## # A tibble: 365 x 5
##    year month   day avg_delay avg_positive_delay
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;              &lt;dbl&gt;
## 1  2013     1     1     12.7                32.5
## 2  2013     1     2     12.7                32.0
## 3  2013     1     3      5.73               27.7
## 4  2013     1     4     -1.93               28.3
## 5  2013     1     5     -1.53               22.6
## 6  2013     1     6      4.24               24.4
## # … with 359 more rows
```
---
class: clear

```r
not_canceled %&gt;% group_by(dest) %&gt;% 
  summarize(dist_sd = sd(distance)) %&gt;% arrange(desc(dist_sd))
```

```
## # A tibble: 104 x 2
##   dest  dist_sd
##   &lt;chr&gt;   &lt;dbl&gt;
## 1 EGE     10.5 
## 2 SAN     10.4 
## 3 SFO     10.2 
## 4 HNL     10.0 
## 5 SEA      9.98
## 6 LAS      9.91
## # … with 98 more rows
```
---
class: clear
We note that *summarize* drops all variables except possibly those used to group the data and those variables introduced by the summary statistics. Contrasts the following two approaches

```r
not_canceled %&gt;% group_by(year,month,day) %&gt;%
  summarize(first_dep = first(dep_time), last_dep = last(dep_time))
```

```
## # A tibble: 365 x 5
##    year month   day first_dep last_dep
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;int&gt;    &lt;int&gt;
## 1  2013     1     1       517     2356
## 2  2013     1     2        42     2354
## 3  2013     1     3        32     2349
## 4  2013     1     4        25     2358
## 5  2013     1     5        14     2357
## 6  2013     1     6        16     2355
## # … with 359 more rows
```
---
class: clear

```r
not_canceled %&gt;% group_by(year, month, day) %&gt;%
  mutate(r = min_rank(desc(dep_time))) %&gt;% filter(r %in% range(r))
```

```
## # A tibble: 770 x 20
##    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
## 1  2013     1     1      517            515         2      830            819
## 2  2013     1     1     2356           2359        -3      425            437
## 3  2013     1     2       42           2359        43      518            442
## 4  2013     1     2     2354           2359        -5      413            437
## 5  2013     1     3       32           2359        33      504            442
## 6  2013     1     3     2349           2359       -10      434            445
## # … with 764 more rows, and 12 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;,
## #   flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, r &lt;int&gt;
```
---
# More examples

```r
not_canceled %&gt;% group_by(year, month, day) %&gt;%
  summarize(n_early = sum(dep_time &lt; 500))
```

```
## # A tibble: 365 x 4
##    year month   day n_early
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;int&gt;
## 1  2013     1     1       0
## 2  2013     1     2       3
## 3  2013     1     3       4
## 4  2013     1     4       3
## 5  2013     1     5       3
## 6  2013     1     6       2
## # … with 359 more rows
```
---
class: clear

```r
not_canceled %&gt;% group_by(dest) %&gt;%
  summarize(long_delay_pct = mean(arr_delay &gt; 60)) %&gt;%
  arrange(desc(long_delay_pct))
```

```
## # A tibble: 104 x 2
##   dest  long_delay_pct
##   &lt;chr&gt;          &lt;dbl&gt;
## 1 CAE            0.255
## 2 TUL            0.245
## 3 OKC            0.216
## 4 TYS            0.206
## 5 BHM            0.171
## 6 DSM            0.170
## # … with 98 more rows
```
---
class: clear
Finally, when you group by multiple variables, each call to `\(\mathrm{summary}\)` peels off one level of the grouping, e.g.,

```r
daily &lt;- group_by(flights, dest, month, day)
daily
```

```
## # A tibble: 336,776 x 19
##    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
## 1  2013     1     1      517            515         2      830            819
## 2  2013     1     1      533            529         4      850            830
## 3  2013     1     1      542            540         2      923            850
## 4  2013     1     1      544            545        -1     1004           1022
## 5  2013     1     1      554            600        -6      812            837
## 6  2013     1     1      554            558        -4      740            728
## # … with 336,770 more rows, and 11 more variables: arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;,
## #   air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;
```
---
class:clear

```r
daily %&gt;% summarize(flights = n()) %&gt;% 
          summarize(flights = sum(flights)) %&gt;%
          summarize(flights = sum(flights)) 
```

```
## # A tibble: 105 x 2
##   dest  flights
##   &lt;chr&gt;   &lt;int&gt;
## 1 ABQ       254
## 2 ACK       265
## 3 ALB       439
## 4 ANC         8
## 5 ATL     17215
## 6 AUS      2439
## # … with 99 more rows
```
---
class: clear
Be careful when peeling off nested groupings using a sequence of `\(\mathrm{summarize}\)`; e.g.,


```r
group_by(not_canceled, dest, month) %&gt;% 
  summarize(air_time = median(air_time)) %&gt;% 
  summarize(air_time = median(air_time))
```

```
## # A tibble: 104 x 2
##   dest  air_time
##   &lt;chr&gt;    &lt;dbl&gt;
## 1 ABQ      244  
## 2 ACK       40.5
## 3 ALB       31  
## 4 ANC      415. 
## 5 ATL      110  
## 6 AUS      214. 
## # … with 98 more rows
```

```r
group_by(not_canceled, dest) %&gt;% 
  summarize(air_time = median(air_time))
```

```
## # A tibble: 104 x 2
##   dest  air_time
##   &lt;chr&gt;    &lt;dbl&gt;
## 1 ABQ       246 
## 2 ACK        41 
## 3 ALB        31 
## 4 ANC       414.
## 5 ATL       112 
## 6 AUS       211 
## # … with 98 more rows
```
---
#ungroup()
To remove grouping structure on grouped data, use `\(\mathrm{ungroup()}\)`, e.g.,

```r
daily &lt;- group_by(flights, year, month, day)
summarize(daily, flights = n())
```

```
## # A tibble: 365 x 4
##    year month   day flights
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;int&gt;
## 1  2013     1     1     842
## 2  2013     1     2     943
## 3  2013     1     3     914
## 4  2013     1     4     915
## 5  2013     1     5     720
## 6  2013     1     6     832
## # … with 359 more rows
```

```r
daily %&gt;% ungroup() %&gt;% summarize(flights = n())
```

```
## # A tibble: 1 x 1
##   flights
##     &lt;int&gt;
## 1  336776
```
---
#grouped_mutate and grouped_filter
We can also do a number of very useful operations by combining `\(\mathrm{group\_by}\)` with either `\(\mathrm{filter}\)` or `\(\mathrm{mutate}\)`. For example

```r
## Find the worst flights with longest delay each day
flights_sml &lt;- select(flights, year:day, ends_with("delay"),
                      distance, air_time)
flights_sml %&gt;% group_by(year, month, day) %&gt;%
  filter(rank(desc(arr_delay)) &lt;= 10)
```

```
## # A tibble: 3,609 x 7
##    year month   day dep_delay arr_delay distance air_time
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;    &lt;dbl&gt;
## 1  2013     1     1       853       851      184       41
## 2  2013     1     1       290       338     1134      213
## 3  2013     1     1       260       263      266       46
## 4  2013     1     1       155       166      277       68
## 5  2013     1     1       157       174      213       60
## 6  2013     1     1       216       222      708      121
## # … with 3,603 more rows
```
---
class: clear

```r
## Find all popular destinations and compute
## proportion of total delay for each flights
flights %&gt;% group_by(dest) %&gt;%
  filter(n() &gt; 365, arr_delay &gt; 0) %&gt;%
  mutate(prop_delay = arr_delay/sum(arr_delay)) %&gt;%
  select(year:day, dest, arr_delay, prop_delay)
```

```
## # A tibble: 131,106 x 6
##    year month   day dest  arr_delay prop_delay
##   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt;     &lt;dbl&gt;      &lt;dbl&gt;
## 1  2013     1     1 IAH          11  0.000111 
## 2  2013     1     1 IAH          20  0.000201 
## 3  2013     1     1 MIA          33  0.000235 
## 4  2013     1     1 ORD          12  0.0000424
## 5  2013     1     1 FLL          19  0.0000938
## 6  2013     1     1 ORD           8  0.0000283
## # … with 131,100 more rows
```
---
class: clear
Functions that work most naturally in grouped mutates and grouped filters are [window functions](https://rpubs.com/hadley/window) (see the **R** command `\(\mathrm{vignette("window-functions")}\)`. 

The following example is from [window functions](https://rpubs.com/hadley/window). The example uses a dataset from the **Lahman** database that contains pitching, hitting, and fielding statistics for MLB from `\(1871\)` through `\(2018\)`. We will consider a sample of batting data for players that have won an award.

```r
library(Lahman)
batting &lt;- Lahman::Batting %&gt;% as.tibble() %&gt;% 
           select(playerID, yearID, teamID, G, AB, R, H) %&gt;%
           arrange(playerID, yearID, teamID) %&gt;%
           semi_join(Lahman::AwardsPlayers, by = "playerID")
players &lt;- batting %&gt;% group_by(playerID)
```
---
class: clear
Using this dataset, let us try a few `\(\mathrm{group\_mutate}\)` and `\(\mathrm{group\_filter}\)` operations. 

```r
## For each player, find the two years with most hits
filter(players, min_rank(desc(H)) &lt;= 2 &amp; H &gt; 0)
```

```
## # A tibble: 2,777 x 7
##   playerID  yearID teamID     G    AB     R     H
##   &lt;chr&gt;      &lt;int&gt; &lt;fct&gt;  &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;
## 1 aaronha01   1959 ML1      154   629   116   223
## 2 aaronha01   1963 ML1      161   631   121   201
## 3 abbotji01   1999 MIL       20    21     0     2
## 4 abernte02   1955 WS1       40    26     1     4
## 5 abernte02   1957 WS1       26    24     3     4
## 6 abreubo01   1999 PHI      152   546   118   183
## # … with 2,771 more rows
```
---
class: clear

```r
## For each player, rank each year by the number of games played
mutate(players, G_rank = min_rank(G))
```

```
## # A tibble: 19,978 x 8
##   playerID  yearID teamID     G    AB     R     H G_rank
##   &lt;chr&gt;      &lt;int&gt; &lt;fct&gt;  &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;int&gt;
## 1 aaronha01   1954 ML1      122   468    58   131      4
## 2 aaronha01   1955 ML1      153   602   105   189     13
## 3 aaronha01   1956 ML1      153   609   106   200     13
## 4 aaronha01   1957 ML1      151   615   118   198     12
## 5 aaronha01   1958 ML1      153   601   109   196     13
## 6 aaronha01   1959 ML1      154   629   116   223     17
## # … with 19,972 more rows
```
---
class: clear

```r
## For each player, find every year that was 
## better than the previous year
filter(players, AB &gt; 0, lag(AB) &gt; 0, H/AB &gt; lag(H)/lag(AB))
```

```
## # A tibble: 7,945 x 7
##   playerID  yearID teamID     G    AB     R     H
##   &lt;chr&gt;      &lt;int&gt; &lt;fct&gt;  &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;
## 1 aaronha01   1955 ML1      153   602   105   189
## 2 aaronha01   1956 ML1      153   609   106   200
## 3 aaronha01   1958 ML1      153   601   109   196
## 4 aaronha01   1959 ML1      154   629   116   223
## 5 aaronha01   1961 ML1      155   603   115   197
## 6 aaronha01   1964 ML1      145   570   103   187
## # … with 7,939 more rows
```
---
class: clear

```r
# For each, player compute a z score based on number of games played
mutate(players, G_z = (G - mean(G)) / sd(G))
```

```
## # A tibble: 19,978 x 8
##   playerID  yearID teamID     G    AB     R     H    G_z
##   &lt;chr&gt;      &lt;int&gt; &lt;fct&gt;  &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;dbl&gt;
## 1 aaronha01   1954 ML1      122   468    58   131 -1.16 
## 2 aaronha01   1955 ML1      153   602   105   189  0.519
## 3 aaronha01   1956 ML1      153   609   106   200  0.519
## 4 aaronha01   1957 ML1      151   615   118   198  0.411
## 5 aaronha01   1958 ML1      153   601   109   196  0.519
## 6 aaronha01   1959 ML1      154   629   116   223  0.573
## # … with 19,972 more rows
```
---
class: clear
The `\(\mathrm{ntile(x,m)}\)` function divides the (numeric) vector `\(x\)` into `\(m\)` evenly sized buckets. The next operation divides the team players into `\(4\)` coarse groups and calculate the batting average for each group.

```r
batting %&gt;% group_by(teamID,playerID) %&gt;%
  summarise(total_hits = sum(H), total_ab = sum(AB), 
            batting_avg = total_hits/total_ab) %&gt;%
  filter(!is.na(batting_avg)) %&gt;%
  mutate(quartile = ntile(batting_avg,4)) %&gt;%
  group_by(teamID,quartile) %&gt;% 
  summarise(batting_avg = sum(total_hits)/sum(total_ab))
```

```
## # A tibble: 235 x 3
##   teamID quartile batting_avg
##   &lt;fct&gt;     &lt;int&gt;       &lt;dbl&gt;
## 1 ANA           1       0.184
## 2 ANA           2       0.258
## 3 ANA           3       0.281
## 4 ANA           4       0.301
## 5 ARI           1       0.157
## 6 ARI           2       0.255
## # … with 229 more rows
```
---
#Scoped variants of dplyr verbs
The dplyr verbs we see before also have **scoped** variants with the suffixes `\(\_\mathrm{if}\)`, `\(\_\mathrm{at}\)` and `\(\_\mathrm{all}\)`. 

+ `\(\_\mathrm{if}\)` pick variables based on a *predicate* function, e.g., `\(\mathrm{is.numeric()}\)`.
+ `\(\_\mathrm{at}\)` pick variables using the same syntax as `\(\mathrm{select}\)`
+ `\(\_\mathrm{all}\)` operates on all variables.

These variants are best illustrated using examples. For more details see the [cheat sheet](https://github.com/dcl-docs/cheat-sheets/blob/master/scoped_verbs.md).

---
#summarise and do
Continuing the above theme. Suppose we want to find the quantiles for `\(\mathrm{arr\_delay}\)` as grouped by popular destination.
We first try the following code.

```r
pop_dest &lt;- flights %&gt;% 
  group_by(dest) %&gt;% 
  filter(n() &gt; 365,!is.na(arr_delay))
pop_dest %&gt;% summarise(delay_quantile = quantile(arr_delay))
```

```
## Error: Column `delay_quantile` must be length 1 (a summary value), not 5
```

The code doesn't work. Let us first simplify the problem and find the quantiles for 
`\(\mathrm{arr\_delay}\)` for the **ungrouped** data.

```r
pop_dest %&gt;% ungroup() %&gt;% 
  summarise(delay_quantile = quantile(arr_delay))
```

```
## Error: Column `delay_quantile` must be length 1 (a summary value), not 5
```
---
class: clear
We see the same error message. After some thought (googling?), we realize that the issue is because **dplyr** verbs takes as input a data frame and outputs another data frame. The output of `\(\mathrm{quantile}\)` is not a data frame. Helper functions to the rescue.

```r
quantile(pop_dest$arr_delay,na.rm = TRUE)
```

```
##   0%  25%  50%  75% 100% 
##  -86  -17   -5   14 1272
```

```r
my_quantile &lt;- function(df){
  z &lt;- quantile(df$arr_delay,na.rm = TRUE)
  tibble(min = z[1], percentile25 = z[2], median = z[3], 
         percentile75 = z[4], max = z[5])
}
pop_dest %&gt;% ungroup() %&gt;% summarise(my_quantile) ## Oops!
```

```
## Error: Column `my_quantile` is of unsupported type function
```

```r
pop_dest %&gt;% ungroup() %&gt;% my_quantile ### Yay!
```

```
## # A tibble: 1 x 5
##     min percentile25 median percentile75   max
##   &lt;dbl&gt;        &lt;dbl&gt;  &lt;dbl&gt;        &lt;dbl&gt; &lt;dbl&gt;
## 1   -86          -17     -5           14  1272
```
---
class: clear
Let us now un-un-group the (grouped) data.

```r
pop_dest %&gt;% my_quantile ### Oops!
```

```
## # A tibble: 1 x 5
##     min percentile25 median percentile75   max
##   &lt;dbl&gt;        &lt;dbl&gt;  &lt;dbl&gt;        &lt;dbl&gt; &lt;dbl&gt;
## 1   -86          -17     -5           14  1272
```
Our helper function `\(\mathrm{my\_quantile}\)` does not understand grouped vs ungrouped data.
Luckily, since we "Think and do", after some thinking (googling?)

```r
pop_dest %&gt;% 
  do(my_quantile(.))
```

```
## # A tibble: 77 x 6
##   dest    min percentile25 median percentile75   max
##   &lt;chr&gt; &lt;dbl&gt;        &lt;dbl&gt;  &lt;dbl&gt;        &lt;dbl&gt; &lt;dbl&gt;
## 1 ALB     -34        -17       -4         28     328
## 2 ATL     -49        -12       -1         16     895
## 3 AUS     -59        -19       -5         15     349
## 4 BDL     -43        -18      -10         14     266
## 5 BGR     -43        -21.8     -9         19.8   238
## 6 BNA     -58        -15       -2         19     364
## # … with 71 more rows
```
---
class: clear
The help page for `\(\mathrm{dplyr::do}\)` reads

&lt;img src="figures/dplyr_do.png" width="70%" style="display: block; margin: auto;" /&gt;

See also section 5.12 of [Introduction to Data Science](https://rafalab.github.io/dsbook/tidyverse.html#do)
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "zenburn",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
